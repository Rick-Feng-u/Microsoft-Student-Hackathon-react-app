import { __assign, __rest } from "tslib";
/** @jsx withSlots */
import { buildUseTokens } from './useTokens';
import { applyTokenLayers } from '@fluentui-react-native/use-tokens';
import { Text, View } from 'react-native';
import { compressible } from './compressible';
import { mergeStyles } from '@fluentui-react-native/merge-props';
import { useSlot, withSlots } from '@fluentui-react-native/use-slot';
import toJson from 'enzyme-to-json';
import { mount } from 'enzyme';
var useVariantTokens = buildUseTokens({
    color: 'black',
    fontSize: 12,
    fontWeight: '500',
    defaultType: 'normal',
    header: {
        color: 'blue',
        fontSize: 16,
        fontWeight: '700',
    },
    caption: {
        color: 'gray',
        fontWeight: '300',
    },
});
var VariantText = compressible(function (props, useTokens) {
    var _a;
    // fake theme here
    var theme = {};
    // get the tokens
    var _b = useTokens(theme), tokens = _b[0], cache = _b[1];
    // split the props, defaulting the variant type to the default type from the tokens
    var _c = props.variant, variant = _c === void 0 ? tokens.defaultType : _c, style = props.style, rest = __rest(props, ["variant", "style"]);
    // now apply the alternate layer tokens as appropriate
    _a = applyTokenLayers(tokens, ['normal', 'header', 'caption'], cache, function (layer) { return layer === variant; }), tokens = _a[0], cache = _a[1];
    // merge styles together with what is passed in
    var mergedStyle = mergeStyles({ color: tokens.color, fontSize: tokens.fontSize, fontWeight: tokens.fontWeight }, style);
    // now get the slot
    var InnerText = useSlot(Text, __assign(__assign({}, rest), { style: mergedStyle }));
    return function (extra, children) {
        return withSlots(InnerText, __assign({}, extra), children);
    };
}, useVariantTokens);
var SuperHeader = VariantText.customize({ header: { fontSize: 24, color: 'purple' } });
var useLabelTokens = buildUseTokens({
    headerVariant: 'header',
    captionVariant: 'caption',
});
var Label = compressible(function (props, useTokens) {
    var theme = {};
    var tokens = useTokens(theme)[0];
    var headerText = props.headerText, captionText = props.captionText, headerSlot = props.headerSlot, captionSlot = props.captionSlot;
    var Header = useSlot(headerSlot || VariantText, { variant: tokens.headerVariant });
    var Caption = useSlot(captionSlot || VariantText, { variant: tokens.captionVariant });
    return function () {
        if (captionText) {
            return (withSlots(View, null,
                withSlots(Header, null, headerText),
                withSlots(Caption, null, captionText)));
        }
        return withSlots(Header, null, headerText);
    };
}, useLabelTokens);
/**
 * this wrapper solves the (so-far) inexplicable type errors from the matchers in typescript
 */
function snapshotTestTree(tree) {
    expect(toJson(tree)).toMatchSnapshot();
}
describe('compressible tests', function () {
    /** first render the component with no updates */
    it('Two labels, one with caption and one without', function () {
        var tree = mount(withSlots(View, null,
            withSlots(Label, { headerText: "Header1" }),
            withSlots(Label, { headerText: "Header2", captionText: "Caption2" })));
        snapshotTestTree(tree);
    });
    it('Two labels, one plugging in SuperHeader instead', function () {
        var tree = mount(withSlots(View, null,
            withSlots(Label, { headerText: "Super Header", headerSlot: SuperHeader, captionText: "Normal caption" }),
            withSlots(Label, { headerText: "Normal Header", captionText: "Another normal caption" })));
        snapshotTestTree(tree);
    });
});
//# sourceMappingURL=compressible.test.js.map