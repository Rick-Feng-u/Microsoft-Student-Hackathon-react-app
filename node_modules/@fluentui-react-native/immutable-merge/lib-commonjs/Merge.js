"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * built in handlers for the module
 */
var _builtinHandlers = {
    appendArray: function () {
        var objs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            objs[_i] = arguments[_i];
        }
        return [].concat.apply([], objs);
    },
};
/**
 * This processes the various type options for merge core and turns them into a MergeConfig
 * @param options - options passed into immutableMergeCore
 */
function normalizeOptions(options) {
    return typeof options === 'boolean'
        ? [{ object: options }, options]
        : typeof options === 'number'
            ? [{ object: options >= 0 ? options : true }, options !== 0]
            : [options, true];
}
/**
 * Return the type except return 'array' for objects that are arrays
 * @param val - value to check type
 */
function getEntityType(val) {
    return typeof val === 'object' ? (Array.isArray(val) ? 'array' : 'object') : typeof val;
}
/** resolve custom handlers if they are applicable */
function resolveIfHandler(option) {
    return typeof option === 'function' ? option : typeof option === 'string' ? _builtinHandlers[option] : undefined;
}
/** pass array configurations down, this allows for saying all arrays should be appended rather than replaced */
function getTypesMixin(config) {
    return config.array ? { array: config.array } : {};
}
/** resolve the object behaviors for configuration */
function resolveForObject(option, mixin) {
    if (typeof option === 'boolean') {
        // booleans won't recurse if false, otherwise recurse infinitely
        return option ? __assign({ object: option }, mixin) : mixin;
    }
    else if (typeof option === 'number') {
        // numbers get decremented or set to false if we've reached zero.  Negative values will have been converted to boolean true
        return option === 0 ? mixin : __assign({ object: option - 1 }, mixin);
    }
    else {
        // otherwise it is an object type so just pass the child object through
        return option;
    }
}
/**
 * Figure out the handler for this property.
 * It will either be a function, a config object to pass to a recursive call, or undefined
 * in the undefined case, this key will be left as-is
 */
function getHandlerForPropertyOfType(config, propKey, propType) {
    var result = undefined;
    var option = config[propKey] !== undefined ? config[propKey] : config[propType] !== undefined ? config[propType] : undefined;
    if (option !== undefined) {
        // try to resolve the option as a handler, either function or built-in first.  This is the only option that is valid for non-object types.
        result = resolveIfHandler(option);
        // if it is an object then resolve boolean, number or config types
        if (result === undefined && propType === 'object') {
            result = resolveForObject(option, getTypesMixin(config));
        }
    }
    return result;
}
/**
 * This will merge two or more objects together using an immutable style merge pattern.  If there is only one object or
 * if there is only one object with values, that object itself will be returned, with two or more objects the keys within will
 * be first merged with Object.assign and then optionally will recurse to merge sub objects as specified by the options.
 *
 * Note that this tries hard to not create extra objects, because of this merging an object with an empty object will not
 * create a new object.
 *
 * @param mergeOptions - options driving behavior of the merge.  See MergeOptions for a description
 * @param singleMode - normally if there is only one branch to follow in the merge the routine will not recurse.  If single mode
 * is true the routine will progress through all branches of the hierarchy.  Useful if using a processor function that needs to be run.
 * @param objs - an array of objects to merge together
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function immutableMergeWorker(mergeOptions, singleMode) {
    var objs = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        objs[_i - 2] = arguments[_i];
    }
    var setToMerge = objs.filter(function (v) { return v && getEntityType(v) === 'object' && Object.getOwnPropertyNames(v).length > 0; });
    var _a = normalizeOptions(mergeOptions), options = _a[0], mightRecurse = _a[1];
    var processSingle = singleMode && setToMerge.length === 1;
    // there is work to do if there is more than one object to merge or if we are processing single objects
    if (setToMerge.length > 1 || (processSingle && setToMerge.length === 1)) {
        // now assign everything to get the normal property precedence (and merge all the keys)
        var result = processSingle ? undefined : Object.assign.apply(Object, __spreadArrays([{}], setToMerge));
        var processSet = result || setToMerge[0];
        var _loop_1 = function (key) {
            if (processSet.hasOwnProperty(key)) {
                // only process if there is potential work to do
                if (mightRecurse) {
                    var originalVal = processSet[key];
                    var entityType = getEntityType(originalVal);
                    var handler = getHandlerForPropertyOfType(options, key, entityType);
                    if (handler !== undefined) {
                        var values = setToMerge.map(function (set) { return set[key]; }).filter(function (v) { return v !== undefined; });
                        var updatedVal = typeof handler === 'function' ? handler.apply(void 0, values) : immutableMergeWorker.apply(void 0, __spreadArrays([handler, singleMode], values));
                        if (updatedVal !== originalVal) {
                            result = result || Object.assign.apply(Object, __spreadArrays([{}], setToMerge));
                            result[key] = updatedVal;
                        }
                    }
                }
                // delete undefined keys from the object, otherwise there is no easy way to delete keys
                if (!processSingle && result[key] === undefined) {
                    delete result[key];
                }
            }
        };
        for (var key in processSet) {
            _loop_1(key);
        }
        // in the single processing case return the original if nothing changed, otherwise return result
        return result || processSet;
    }
    return setToMerge.length > 0 ? setToMerge[0] : undefined;
}
/**
 * Recursively immutable merge sets of objects infinitely deep.  This behaves like a standard deep merge with arrays replacing
 * one another rather than appending.  If appending arrays is desireable this can be configured via immutableMergeCore
 *
 * @param objs - variable input array of typed objects to merge
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function immutableMerge() {
    var objs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objs[_i] = arguments[_i];
    }
    return immutableMergeWorker.apply(void 0, __spreadArrays([true, false], objs));
}
exports.immutableMerge = immutableMerge;
/**
 * Version of immutable merge that can be configured to behave in a variety of manners.  See the documentation for details.
 *
 * @param options - configuration options for the merge, this dictates what keys will be handled in what way
 * @param objs - set of objects to merge together
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function immutableMergeCore(options) {
    var objs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        objs[_i - 1] = arguments[_i];
    }
    return immutableMergeWorker.apply(void 0, __spreadArrays([options, false], objs));
}
exports.immutableMergeCore = immutableMergeCore;
/**
 * Process one or more immutable objects ensuring that handlers are called on every entry that applies.  If a single object
 * is passed in and no changes are made, that object will be returned.  If updates happen from the handlers it will return the
 * minimally mutated object.
 *
 * The use case for this might be a style transformation on a deeply nested object.  If no changes are made the object won't be
 * updated but in the case where something needs to be transformed this will perform the minimal mutations.
 *
 * @param processors - set of processor functions for handling keys
 * @param objs - one or more objects to process.  If multiple objects are passed they will be merged
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function processImmutable(options) {
    var objs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        objs[_i - 1] = arguments[_i];
    }
    return immutableMergeWorker.apply(void 0, __spreadArrays([options, true], objs));
}
exports.processImmutable = processImmutable;
//# sourceMappingURL=Merge.js.map