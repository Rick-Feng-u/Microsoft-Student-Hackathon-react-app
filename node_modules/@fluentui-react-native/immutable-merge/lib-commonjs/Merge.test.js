"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var Merge_1 = require("./Merge");
var sett1 = {
    root: {
        p2: 1,
        nm: { nm1: 1 },
        style: { s1: 'foo', s2: 2, nm: { nm1: 1 } },
    },
    fakeSlot: {
        ps2: 2,
    },
};
var sett2 = {
    root: {
        p1: 'sett2',
        p2: 2,
        nm: { nm2: 2 },
    },
    fakeSlot: {
        style: { s1: 'sett2' },
    },
};
var sett1plus2 = {
    root: {
        p1: 'sett2',
        p2: 2,
        nm: { nm2: 2 },
        style: { s1: 'foo', s2: 2, nm: { nm1: 1 } },
    },
    fakeSlot: {
        ps2: 2,
        style: { s1: 'sett2' },
    },
};
var sett3 = {
    root: {
        p1: 'sett3',
        style: { s2: 3, nm: { nm2: 2 } },
    },
};
var sett1plus3 = {
    root: {
        p1: 'sett3',
        p2: 1,
        nm: { nm1: 1 },
        style: { s1: 'foo', s2: 3, nm: { nm2: 2 } },
    },
    fakeSlot: {
        ps2: 2,
    },
};
var sett1plus2plus3 = {
    root: {
        p1: 'sett3',
        p2: 2,
        nm: { nm2: 2 },
        style: { s1: 'foo', s2: 3, nm: { nm2: 2 } },
    },
    fakeSlot: {
        ps2: 2,
        style: { s1: 'sett2' },
    },
};
var mergeOptions = {
    object: {
        style: 0,
    },
};
var deep1 = {
    a: { b: { c: 1 } },
    b: { c: { d: { d: 'foo' } } },
    c: { e: 4 },
};
var deep2 = {
    a: { b1: 3, b: { c: 2 } },
    b: { c: { d2: 'bar' } },
    c: { e2: { f: 'baz' } },
};
var deepMerged = {
    a: { b1: 3, b: { c: 2 } },
    b: { c: { d: { d: 'foo' }, d2: 'bar' } },
    c: { e: 4, e2: { f: 'baz' } },
};
var singleToChange = {
    a: { b: { c: { changeMe: { color: 'blue' } } } },
    b: { d: { changeMe: { font: 'fixed' } } },
};
var singleWithChanges = {
    a: { b: { c: { changeMe: { color: 'changed' } } } },
    b: { d: { changeMe: { font: 'fixed' } } },
};
var _colorKey = 'color';
var changeMeHandler = function () {
    var objs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objs[_i] = arguments[_i];
    }
    // written always assuming only one entry
    if (objs.length === 1) {
        var firstObj = objs[0];
        if (firstObj[_colorKey]) {
            return __assign(__assign({}, firstObj), { color: 'changed' });
        }
        return firstObj;
    }
    return undefined;
};
var changeMeOption1 = {
    a: {
        b: {
            c: {
                changeMe: changeMeHandler,
            },
        },
    },
};
var changeMeOption2 = {
    object: {
        object: {
            object: {
                changeMe: changeMeHandler,
            },
            changeMe: changeMeHandler,
        },
    },
};
describe('Immutable merge unit tests', function () {
    test('merge one returns same object', function () {
        var obj = {
            a: 'a',
            b: 2,
        };
        expect(Merge_1.immutableMerge(obj, undefined)).toBe(obj);
        expect(Merge_1.immutableMerge(undefined, obj)).toBe(obj);
    });
    test('merge flat is like assign', function () {
        var obj1 = { a: 'a', b: 1 };
        var obj2 = { b: 2, c: true };
        var merged = { a: 'a', b: 2, c: true };
        expect(Merge_1.immutableMerge(obj1, obj2)).toEqual(merged);
        expect(Merge_1.immutableMergeCore(0, obj1, obj2)).toEqual(merged);
        expect(Merge_1.immutableMergeCore(true, obj1, obj2)).toEqual(merged);
    });
    var dm1 = {
        a: { b: { c: { foo: 'foo', bar: 'bar' } } },
        d: { e: 1, f: { g: 'hello', h: 2 } },
    };
    var dm2 = {
        a: { b: { c: { bar: 'bar2', baz: 'baz' } }, i: 'world' },
        d: { j: 4 },
    };
    test('deep merge', function () {
        expect(Merge_1.immutableMerge(dm1, dm2)).toEqual({
            a: { b: { c: { foo: 'foo', bar: 'bar2', baz: 'baz' } }, i: 'world' },
            d: { e: 1, f: { g: 'hello', h: 2 }, j: 4 },
        });
    });
    test('merge zero levels', function () {
        expect(Merge_1.immutableMergeCore(0, dm1, dm2)).toEqual(dm2);
    });
    test('merge one level deep', function () {
        var result = {
            a: dm2.a,
            d: __assign(__assign({}, dm1.d), dm2.d),
        };
        expect(Merge_1.immutableMergeCore(1, dm1, dm2)).toEqual(result);
        expect(Merge_1.immutableMergeCore({ object: 0 }, dm1, dm2)).toEqual(result);
    });
    test('merge with empty object', function () {
        var merged = Merge_1.immutableMergeCore(mergeOptions, sett1, {});
        expect(merged).toBe(sett1);
        var merged2 = Merge_1.immutableMergeCore(mergeOptions, {}, sett2);
        expect(merged2).toBe(sett2);
    });
    test('merge sett1 and sett2', function () {
        var merged = Merge_1.immutableMergeCore(mergeOptions, sett1, sett2);
        expect(merged).toEqual(sett1plus2);
        expect(merged.root.style).toBe(sett1.root.style);
        expect(merged.fakeSlot.style).toBe(sett2.fakeSlot.style);
    });
    test('merge sett1 and sett3', function () {
        var merged = Merge_1.immutableMergeCore(mergeOptions, sett1, sett3);
        expect(merged).toEqual(sett1plus3);
        expect(merged.fakeSlot).toBe(sett1.fakeSlot);
    });
    test('merge three', function () {
        var merged = Merge_1.immutableMergeCore(mergeOptions, sett1, sett2, sett3);
        expect(merged).toEqual(sett1plus2plus3);
    });
    test('deepMerge', function () {
        var merged = Merge_1.immutableMergeCore(-1, deep1, deep2);
        expect(merged).toEqual(deepMerged);
        expect(merged.b.c.d).toBe(deep1.b.c.d);
        expect(merged.a.b).not.toBe(deep2.a.b);
    });
    test('singleProcessNoChange', function () {
        var merged = Merge_1.processImmutable({ object: true }, singleToChange);
        expect(merged).toBe(singleToChange);
    });
    test('single process with change', function () {
        var merged = Merge_1.processImmutable(changeMeOption1, singleToChange);
        expect(merged).toEqual(singleWithChanges);
        expect(merged).not.toBe(singleToChange);
        expect(merged.b).toBe(singleToChange.b);
    });
    test('single process with change - alternative', function () {
        var merged = Merge_1.processImmutable(changeMeOption2, singleToChange);
        expect(merged).toEqual(singleWithChanges);
        expect(merged).not.toBe(singleToChange);
        expect(merged.b).toBe(singleToChange.b);
    });
    var withArray1 = {
        baseArray: [1, 2, 3],
        sub: { subArray: ['a', 'b', 'c'] },
    };
    var withArray2 = {
        baseArray: [4, 5, 6],
        sub: { subArray: ['d', 'e', 'f'] },
    };
    test('arrays overwrite each other', function () {
        var merged = Merge_1.immutableMergeCore({ depth: -1 }, withArray1, withArray2);
        expect(merged).toEqual(withArray2);
        expect(merged).not.toBe(withArray2);
    });
    var withObj = {
        a: { foo: 'bar' },
        b: 2,
    };
    var withNonObj = {
        a: 'hello',
        b: 3,
    };
    test('last writer wins for objects and non-objects', function () {
        var merged = Merge_1.immutableMerge(withObj, withNonObj);
        expect(merged).toEqual(withNonObj);
        var merged2 = Merge_1.immutableMerge(withNonObj, withObj);
        expect(merged2).toEqual(withObj);
    });
    var arrayMerger = function () {
        var targets = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            targets[_i] = arguments[_i];
        }
        var arrays = targets.filter(function (t) { return Array.isArray(t); });
        var result = [];
        arrays.forEach(function (v) { return (result = result.concat.apply(result, v)); });
        return result;
    };
    test('arrays can merge with handler', function () {
        var merged = Merge_1.immutableMergeCore({
            object: {
                subArray: arrayMerger,
            },
        }, withArray1, withArray2);
        expect(merged).toEqual({
            baseArray: [4, 5, 6],
            sub: { subArray: ['a', 'b', 'c', 'd', 'e', 'f'] },
        });
    });
    test('arrays can merge deeply', function () {
        var merged = Merge_1.immutableMergeCore({
            object: true,
            array: 'appendArray',
        }, withArray1, withArray2);
        expect(merged).toEqual({
            baseArray: [1, 2, 3, 4, 5, 6],
            sub: { subArray: ['a', 'b', 'c', 'd', 'e', 'f'] },
        });
    });
});
//# sourceMappingURL=Merge.test.js.map