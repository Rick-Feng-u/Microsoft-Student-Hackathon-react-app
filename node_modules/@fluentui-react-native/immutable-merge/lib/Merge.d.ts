/**
 * The basic options for recursion at a given level.  Two types for two behaviors:
 *
 * boolean:
 *  - if true, recurse indefinitely
 *  - if false, don't recurse
 *
 * number:
 *  - if 0, don't recurse from this level
 *  - if > 0, recurse that many times then stop
 *  - if < 0, recurse indefinitely
 */
export declare type RecursionOption = boolean | number;
/**
 * a function that can be set to merge arguments
 */
export declare type CustomRecursionHandler = (...vals: any[]) => any;
/**
 * built in handler functions that can be applied for a given key
 */
export declare type BuiltinRecursionHandlers = 'appendArray';
/**
 * Handlers for recursion of a given key or type.  These can either be functions or a reference to a supported
 * built-in merge routine
 */
export declare type RecursionHandler = BuiltinRecursionHandlers | CustomRecursionHandler;
/**
 * configuration object for the merge, key names are matched with a few exceptions:
 * - object: matches non-array object types
 * - array: matches array types
 * - [key: string]: matches anything by name
 */
export interface MergeOptions {
    [objectTypeOrKeyName: string]: RecursionOption | RecursionHandler | MergeOptions;
}
/**
 * Recursively immutable merge sets of objects infinitely deep.  This behaves like a standard deep merge with arrays replacing
 * one another rather than appending.  If appending arrays is desireable this can be configured via immutableMergeCore
 *
 * @param objs - variable input array of typed objects to merge
 */
export declare function immutableMerge<T extends object>(...objs: (T | undefined)[]): T | undefined;
/**
 * Version of immutable merge that can be configured to behave in a variety of manners.  See the documentation for details.
 *
 * @param options - configuration options for the merge, this dictates what keys will be handled in what way
 * @param objs - set of objects to merge together
 */
export declare function immutableMergeCore<T extends object>(options: RecursionOption | MergeOptions, ...objs: (T | undefined)[]): T | undefined;
/**
 * Process one or more immutable objects ensuring that handlers are called on every entry that applies.  If a single object
 * is passed in and no changes are made, that object will be returned.  If updates happen from the handlers it will return the
 * minimally mutated object.
 *
 * The use case for this might be a style transformation on a deeply nested object.  If no changes are made the object won't be
 * updated but in the case where something needs to be transformed this will perform the minimal mutations.
 *
 * @param processors - set of processor functions for handling keys
 * @param objs - one or more objects to process.  If multiple objects are passed they will be merged
 */
export declare function processImmutable<T extends object>(options: MergeOptions, ...objs: (T | undefined)[]): T | undefined;
//# sourceMappingURL=Merge.d.ts.map