/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow strict-local
 * @format
 */
'use strict';
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import invariant from 'invariant';
import { Platform, UIManager } from 'react-native';
import { isHoverEnabled } from './HoverState';
import { normalizeRect } from './InternalTypes';
var Transitions = {
    NOT_RESPONDER: {
        DELAY: 'ERROR',
        RESPONDER_GRANT: 'RESPONDER_INACTIVE_PRESS_IN',
        RESPONDER_RELEASE: 'ERROR',
        RESPONDER_TERMINATED: 'ERROR',
        ENTER_PRESS_RECT: 'ERROR',
        LEAVE_PRESS_RECT: 'ERROR',
        LONG_PRESS_DETECTED: 'ERROR',
    },
    RESPONDER_INACTIVE_PRESS_IN: {
        DELAY: 'RESPONDER_ACTIVE_PRESS_IN',
        RESPONDER_GRANT: 'ERROR',
        RESPONDER_RELEASE: 'NOT_RESPONDER',
        RESPONDER_TERMINATED: 'NOT_RESPONDER',
        ENTER_PRESS_RECT: 'RESPONDER_INACTIVE_PRESS_IN',
        LEAVE_PRESS_RECT: 'RESPONDER_INACTIVE_PRESS_OUT',
        LONG_PRESS_DETECTED: 'ERROR',
    },
    RESPONDER_INACTIVE_PRESS_OUT: {
        DELAY: 'RESPONDER_ACTIVE_PRESS_OUT',
        RESPONDER_GRANT: 'ERROR',
        RESPONDER_RELEASE: 'NOT_RESPONDER',
        RESPONDER_TERMINATED: 'NOT_RESPONDER',
        ENTER_PRESS_RECT: 'RESPONDER_INACTIVE_PRESS_IN',
        LEAVE_PRESS_RECT: 'RESPONDER_INACTIVE_PRESS_OUT',
        LONG_PRESS_DETECTED: 'ERROR',
    },
    RESPONDER_ACTIVE_PRESS_IN: {
        DELAY: 'ERROR',
        RESPONDER_GRANT: 'ERROR',
        RESPONDER_RELEASE: 'NOT_RESPONDER',
        RESPONDER_TERMINATED: 'NOT_RESPONDER',
        ENTER_PRESS_RECT: 'RESPONDER_ACTIVE_PRESS_IN',
        LEAVE_PRESS_RECT: 'RESPONDER_ACTIVE_PRESS_OUT',
        LONG_PRESS_DETECTED: 'RESPONDER_ACTIVE_LONG_PRESS_IN',
    },
    RESPONDER_ACTIVE_PRESS_OUT: {
        DELAY: 'ERROR',
        RESPONDER_GRANT: 'ERROR',
        RESPONDER_RELEASE: 'NOT_RESPONDER',
        RESPONDER_TERMINATED: 'NOT_RESPONDER',
        ENTER_PRESS_RECT: 'RESPONDER_ACTIVE_PRESS_IN',
        LEAVE_PRESS_RECT: 'RESPONDER_ACTIVE_PRESS_OUT',
        LONG_PRESS_DETECTED: 'ERROR',
    },
    RESPONDER_ACTIVE_LONG_PRESS_IN: {
        DELAY: 'ERROR',
        RESPONDER_GRANT: 'ERROR',
        RESPONDER_RELEASE: 'NOT_RESPONDER',
        RESPONDER_TERMINATED: 'NOT_RESPONDER',
        ENTER_PRESS_RECT: 'RESPONDER_ACTIVE_LONG_PRESS_IN',
        LEAVE_PRESS_RECT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT',
        LONG_PRESS_DETECTED: 'RESPONDER_ACTIVE_LONG_PRESS_IN',
    },
    RESPONDER_ACTIVE_LONG_PRESS_OUT: {
        DELAY: 'ERROR',
        RESPONDER_GRANT: 'ERROR',
        RESPONDER_RELEASE: 'NOT_RESPONDER',
        RESPONDER_TERMINATED: 'NOT_RESPONDER',
        ENTER_PRESS_RECT: 'RESPONDER_ACTIVE_LONG_PRESS_IN',
        LEAVE_PRESS_RECT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT',
        LONG_PRESS_DETECTED: 'ERROR',
    },
    ERROR: {
        DELAY: 'NOT_RESPONDER',
        RESPONDER_GRANT: 'RESPONDER_INACTIVE_PRESS_IN',
        RESPONDER_RELEASE: 'NOT_RESPONDER',
        RESPONDER_TERMINATED: 'NOT_RESPONDER',
        ENTER_PRESS_RECT: 'NOT_RESPONDER',
        LEAVE_PRESS_RECT: 'NOT_RESPONDER',
        LONG_PRESS_DETECTED: 'NOT_RESPONDER',
    },
};
var isActiveSignal = function (signal) { return signal === 'RESPONDER_ACTIVE_PRESS_IN' || signal === 'RESPONDER_ACTIVE_LONG_PRESS_IN'; };
var isActivationSignal = function (signal) { return signal === 'RESPONDER_ACTIVE_PRESS_OUT' || signal === 'RESPONDER_ACTIVE_PRESS_IN'; };
var isPressInSignal = function (signal) {
    return signal === 'RESPONDER_INACTIVE_PRESS_IN' || signal === 'RESPONDER_ACTIVE_PRESS_IN' || signal === 'RESPONDER_ACTIVE_LONG_PRESS_IN';
};
var isTerminalSignal = function (signal) { return signal === 'RESPONDER_TERMINATED' || signal === 'RESPONDER_RELEASE'; };
var DEFAULT_LONG_PRESS_DELAY_MS = 370; // 500 - 130
var DEFAULT_PRESS_DELAY_MS = 130;
var DEFAULT_PRESS_RECT_OFFSETS = {
    bottom: 30,
    left: 20,
    right: 20,
    top: 20,
};
function normalizeDelay(delay, min, fallback) {
    if (min === void 0) { min = 0; }
    if (fallback === void 0) { fallback = 0; }
    return Math.max(min, delay !== null && delay !== void 0 ? delay : fallback);
}
var getTouchFromPressEvent = function (event) {
    var _a = event.nativeEvent, changedTouches = _a.changedTouches, touches = _a.touches;
    if (touches != null && touches.length > 0) {
        return touches[0];
    }
    if (changedTouches != null && changedTouches.length > 0) {
        return changedTouches[0];
    }
    return event.nativeEvent;
};
/**
 * Pressability implements press handling capabilities.
 *
 * =========================== Pressability Tutorial ===========================
 *
 * The `Pressability` class helps you create press interactions by analyzing the
 * geometry of elements and observing when another responder (e.g. ScrollView)
 * has stolen the touch lock. It offers hooks for your component to provide
 * interaction feedback to the user:
 *
 * - When a press has activated (e.g. highlight an element)
 * - When a press has deactivated (e.g. un-highlight an element)
 * - When a press sould trigger an action, meaning it activated and deactivated
 *   while within the geometry of the element without the lock being stolen.
 *
 * A high quality interaction isn't as simple as you might think. There should
 * be a slight delay before activation. Moving your finger beyond an element's
 * bounds should trigger deactivation, but moving the same finger back within an
 * element's bounds should trigger reactivation.
 *
 * In order to use `Pressability`, do the following:
 *
 * 1. Instantiate `Pressability` and store it on your component's state.
 *
 *    state = {
 *      pressability: new Pressability({
 *        // ...
 *      }),
 *    };
 *
 * 2. Choose the rendered component who should collect the press events. On that
 *    element, spread `pressability.getEventHandlers()` into its props.
 *
 *    return (
 *      <View {...this.state.pressability.getEventHandlers()} />
 *    );
 *
 * 3. Reset `Pressability` when your component unmounts.
 *
 *    componentWillUnmount() {
 *      this.state.pressability.reset();
 *    }
 *
 * ==================== Pressability Implementation Details ====================
 *
 * `Pressability` only assumes that there exists a `HitRect` node. The `PressRect`
 * is an abstract box that is extended beyond the `HitRect`.
 *
 * # Geometry
 *
 *  ┌────────────────────────┐
 *  │  ┌──────────────────┐  │ - Presses start anywhere within `HitRect`, which
 *  │  │  ┌────────────┐  │  │   is expanded via the prop `hitSlop`.
 *  │  │  │ VisualRect │  │  │
 *  │  │  └────────────┘  │  │ - When pressed down for sufficient amount of time
 *  │  │    HitRect       │  │   before letting up, `VisualRect` activates for
 *  │  └──────────────────┘  │   as long as the press stays within `PressRect`.
 *  │       PressRect    o   │
 *  └────────────────────│───┘
 *          Out Region   └────── `PressRect`, which is expanded via the prop
 *                               `pressRectOffset`, allows presses to move
 *                               beyond `HitRect` while maintaining activation
 *                               and being eligible for a "press".
 *
 * # State Machine
 *
 * ┌───────────────┐ ◀──── RESPONDER_RELEASE
 * │ NOT_RESPONDER │
 * └───┬───────────┘ ◀──── RESPONDER_TERMINATED
 *     │
 *     │ RESPONDER_GRANT (HitRect)
 *     │
 *     ▼
 * ┌─────────────────────┐          ┌───────────────────┐              ┌───────────────────┐
 * │ RESPONDER_INACTIVE_ │  DELAY   │ RESPONDER_ACTIVE_ │  T + DELAY   │ RESPONDER_ACTIVE_ │
 * │ PRESS_IN            ├────────▶ │ PRESS_IN          ├────────────▶ │ LONG_PRESS_IN     │
 * └─┬───────────────────┘          └─┬─────────────────┘              └─┬─────────────────┘
 *   │           ▲                    │           ▲                      │           ▲
 *   │LEAVE_     │                    │LEAVE_     │                      │LEAVE_     │
 *   │PRESS_RECT │ENTER_              │PRESS_RECT │ENTER_                │PRESS_RECT │ENTER_
 *   │           │PRESS_RECT          │           │PRESS_RECT            │           │PRESS_RECT
 *   ▼           │                    ▼           │                      ▼           │
 * ┌─────────────┴───────┐          ┌─────────────┴─────┐              ┌─────────────┴─────┐
 * │ RESPONDER_INACTIVE_ │  DELAY   │ RESPONDER_ACTIVE_ │              │ RESPONDER_ACTIVE_ │
 * │ PRESS_OUT           ├────────▶ │ PRESS_OUT         │              │ LONG_PRESS_OUT    │
 * └─────────────────────┘          └───────────────────┘              └───────────────────┘
 *
 * T + DELAY => LONG_PRESS_DELAY + DELAY
 *
 * Not drawn are the side effects of each transition. The most important side
 * effect is the invocation of `onPress` and `onLongPress` that occur when a
 * responder is release while in the "press in" states.
 */
var Pressability = /** @class */ (function () {
    function Pressability(config) {
        var _this = this;
        this._eventHandlers = null;
        this._hoverInDelayTimeout = null;
        this._hoverOutDelayTimeout = null;
        this._isHovered = false;
        this._longPressDelayTimeout = null;
        this._pressDelayTimeout = null;
        this._pressOutDelayTimeout = null;
        this._responderID = null;
        this._responderRegion = null;
        this._touchState = 'NOT_RESPONDER';
        this._measureCallback = function (left, top, width, height, pageX, pageY) {
            if (!left && !top && !width && !height && !pageX && !pageY) {
                return;
            }
            _this._responderRegion = {
                bottom: pageY + height,
                left: pageX,
                right: pageX + width,
                top: pageY,
            };
        };
        this.configure(config);
    }
    Pressability.prototype.configure = function (config) {
        this._config = config;
    };
    /**
     * Resets any pending timers. This should be called on unmount.
     */
    Pressability.prototype.reset = function () {
        this._cancelHoverInDelayTimeout();
        this._cancelHoverOutDelayTimeout();
        this._cancelLongPressDelayTimeout();
        this._cancelPressDelayTimeout();
        this._cancelPressOutDelayTimeout();
    };
    /**
     * Returns a set of props to spread into the interactive element.
     */
    Pressability.prototype.getEventHandlers = function () {
        if (this._eventHandlers == null) {
            this._eventHandlers = this._createEventHandlers();
        }
        return this._eventHandlers;
    };
    Pressability.prototype._createEventHandlers = function () {
        var _this = this;
        var focusEventHandlers = {
            onBlur: function (event) {
                var onBlur = _this._config.onBlur;
                if (onBlur != null) {
                    onBlur(event);
                }
            },
            onFocus: function (event) {
                var onFocus = _this._config.onFocus;
                if (onFocus != null) {
                    onFocus(event);
                }
            },
        };
        var responderEventHandlers = {
            onStartShouldSetResponder: function () {
                var disabled = _this._config.disabled;
                if (disabled == null) {
                    return true;
                }
                return !disabled;
            },
            onResponderGrant: function (event) {
                event.persist();
                _this._cancelPressOutDelayTimeout();
                _this._responderID = event.currentTarget;
                _this._touchState = 'NOT_RESPONDER';
                _this._receiveSignal('RESPONDER_GRANT', event);
                var delayPressIn = normalizeDelay(_this._config.delayPressIn, 0, DEFAULT_PRESS_DELAY_MS);
                if (delayPressIn > 0) {
                    _this._pressDelayTimeout = setTimeout(function () {
                        _this._receiveSignal('DELAY', event);
                    }, delayPressIn);
                }
                else {
                    _this._receiveSignal('DELAY', event);
                }
                var delayLongPress = normalizeDelay(_this._config.delayLongPress, 10, DEFAULT_LONG_PRESS_DELAY_MS);
                _this._longPressDelayTimeout = setTimeout(function () {
                    _this._handleLongPress(event);
                }, delayLongPress + delayPressIn);
            },
            onResponderMove: function (event) {
                if (_this._config.onPressMove != null) {
                    _this._config.onPressMove(event);
                }
                // Region may not have finished being measured, yet.
                var responderRegion = _this._responderRegion;
                if (responderRegion == null) {
                    return;
                }
                var touch = getTouchFromPressEvent(event);
                if (touch == null) {
                    _this._cancelLongPressDelayTimeout();
                    _this._receiveSignal('LEAVE_PRESS_RECT', event);
                    return;
                }
                if (_this._touchActivatePosition != null) {
                    var deltaX = _this._touchActivatePosition.pageX - touch.pageX;
                    var deltaY = _this._touchActivatePosition.pageY - touch.pageY;
                    if (Math.hypot(deltaX, deltaY) > 10) {
                        _this._cancelLongPressDelayTimeout();
                    }
                }
                if (_this._isTouchWithinResponderRegion(touch, responderRegion)) {
                    _this._receiveSignal('ENTER_PRESS_RECT', event);
                }
                else {
                    _this._cancelLongPressDelayTimeout();
                    _this._receiveSignal('LEAVE_PRESS_RECT', event);
                }
            },
            onResponderRelease: function (event) {
                _this._receiveSignal('RESPONDER_RELEASE', event);
            },
            onResponderTerminate: function (event) {
                _this._receiveSignal('RESPONDER_TERMINATED', event);
            },
            onResponderTerminationRequest: function () {
                var cancelable = _this._config.cancelable;
                return cancelable || true;
            },
            onClick: function (event) {
                var onPress = _this._config.onPress;
                if (onPress != null) {
                    onPress(event);
                }
            },
        };
        var mouseEventHandlers = Platform.OS === 'ios' || Platform.OS === 'android'
            ? null
            : {
                onMouseEnter: function (event) {
                    if (isHoverEnabled()) {
                        _this._isHovered = true;
                        _this._cancelHoverOutDelayTimeout();
                        var onHoverIn_1 = _this._config.onHoverIn;
                        if (onHoverIn_1 != null) {
                            var delayHoverIn = normalizeDelay(_this._config.delayHoverIn);
                            if (delayHoverIn > 0) {
                                _this._hoverInDelayTimeout = setTimeout(function () {
                                    onHoverIn_1(event);
                                }, delayHoverIn);
                            }
                            else {
                                onHoverIn_1(event);
                            }
                        }
                    }
                },
                onMouseLeave: function (event) {
                    if (_this._isHovered) {
                        _this._isHovered = false;
                        _this._cancelHoverInDelayTimeout();
                        var onHoverOut_1 = _this._config.onHoverOut;
                        if (onHoverOut_1 != null) {
                            var delayHoverOut = normalizeDelay(_this._config.delayHoverOut);
                            if (delayHoverOut > 0) {
                                _this._hoverInDelayTimeout = setTimeout(function () {
                                    onHoverOut_1(event);
                                }, delayHoverOut);
                            }
                            else {
                                onHoverOut_1(event);
                            }
                        }
                    }
                },
            };
        return __assign(__assign(__assign({}, focusEventHandlers), responderEventHandlers), mouseEventHandlers);
    };
    /**
     * Receives a state machine signal, performs side effects of the transition
     * and stores the new state. Validates the transition as well.
     */
    Pressability.prototype._receiveSignal = function (signal, event) {
        var prevState = this._touchState;
        var nextState = Transitions[prevState][signal];
        if (this._responderID == null && signal === 'RESPONDER_RELEASE') {
            return;
        }
        invariant(nextState != null && nextState !== 'ERROR', 'Pressability: Invalid signal `%s` for state `%s` on responder: %s', signal, prevState, typeof this._responderID === 'number' ? this._responderID : '<<host component>>');
        if (prevState !== nextState) {
            this._performTransitionSideEffects(prevState, nextState, signal, event);
            this._touchState = nextState;
        }
    };
    /**
     * Performs a transition between touchable states and identify any activations
     * or deactivations (and callback invocations).
     */
    Pressability.prototype._performTransitionSideEffects = function (prevState, nextState, signal, event) {
        if (isTerminalSignal(signal)) {
            this._touchActivatePosition = null;
            this._cancelLongPressDelayTimeout();
        }
        var isInitialTransition = prevState === 'NOT_RESPONDER' && nextState === 'RESPONDER_INACTIVE_PRESS_IN';
        var isActivationTransiton = !isActivationSignal(prevState) && isActivationSignal(nextState);
        if (isInitialTransition || isActivationTransiton) {
            this._measureResponderRegion();
        }
        if (isPressInSignal(prevState) && signal === 'LONG_PRESS_DETECTED') {
            var onLongPress = this._config.onLongPress;
            if (onLongPress != null) {
                onLongPress(event);
            }
        }
        var isPrevActive = isActiveSignal(prevState);
        var isNextActive = isActiveSignal(nextState);
        if (!isPrevActive && isNextActive) {
            this._activate(event);
        }
        else if (isPrevActive && !isNextActive) {
            this._deactivate(event);
        }
        if (isPressInSignal(prevState) && signal === 'RESPONDER_RELEASE') {
            var _a = this._config, onLongPress = _a.onLongPress, onPress = _a.onPress /*, android_disableSound */;
            if (onPress != null) {
                var isPressCanceledByLongPress = onLongPress != null && prevState === 'RESPONDER_ACTIVE_LONG_PRESS_IN' && this._shouldLongPressCancelPress();
                if (!isPressCanceledByLongPress) {
                    // If we never activated (due to delays), activate and deactivate now.
                    if (!isNextActive && !isPrevActive) {
                        this._activate(event);
                        this._deactivate(event);
                    }
                    /*
                    if (Platform.OS === 'android' && android_disableSound !== true) {
                      SoundManager.playTouchSound();
                    }
                    */
                    onPress(event);
                }
            }
        }
        this._cancelPressDelayTimeout();
    };
    Pressability.prototype._activate = function (event) {
        var onPressIn = this._config.onPressIn;
        var touch = getTouchFromPressEvent(event);
        this._touchActivatePosition = {
            pageX: touch.pageX,
            pageY: touch.pageY,
        };
        if (onPressIn != null) {
            onPressIn(event);
        }
    };
    Pressability.prototype._deactivate = function (event) {
        var onPressOut = this._config.onPressOut;
        if (onPressOut != null) {
            var delayPressOut = normalizeDelay(this._config.delayPressOut);
            if (delayPressOut > 0) {
                this._pressOutDelayTimeout = setTimeout(function () {
                    onPressOut(event);
                }, delayPressOut);
            }
            else {
                onPressOut(event);
            }
        }
    };
    Pressability.prototype._measureResponderRegion = function () {
        var _a, _b, _c, _d;
        if (this._responderID == null) {
            return;
        }
        if (typeof this._responderID === 'number') {
            UIManager.measure(this._responderID, this._measureCallback);
        }
        else {
            var measure = (_b = (_a = this) === null || _a === void 0 ? void 0 : _a._responderID) === null || _b === void 0 ? void 0 : _b.measure;
            if (typeof measure === 'function' && this._measureCallback) {
                (_d = (_c = this) === null || _c === void 0 ? void 0 : _c._responderID) === null || _d === void 0 ? void 0 : _d.measure(this._measureCallback);
            }
        }
    };
    Pressability.prototype._isTouchWithinResponderRegion = function (touch /* PropertyType<PressEvent, 'nativeEvent'> */, responderRegion) {
        var _a, _b, _c, _d;
        var hitSlop = normalizeRect(this._config.hitSlop);
        var pressRectOffset = normalizeRect(this._config.pressRectOffset);
        var regionBottom = responderRegion.bottom;
        var regionLeft = responderRegion.left;
        var regionRight = responderRegion.right;
        var regionTop = responderRegion.top;
        if (hitSlop != null) {
            if (hitSlop.bottom != null) {
                regionBottom += hitSlop.bottom;
            }
            if (hitSlop.left != null) {
                regionLeft -= hitSlop.left;
            }
            if (hitSlop.right != null) {
                regionRight += hitSlop.right;
            }
            if (hitSlop.top != null) {
                regionTop -= hitSlop.top;
            }
        }
        regionBottom += (_a = pressRectOffset === null || pressRectOffset === void 0 ? void 0 : pressRectOffset.bottom) !== null && _a !== void 0 ? _a : DEFAULT_PRESS_RECT_OFFSETS.bottom;
        regionLeft -= (_b = pressRectOffset === null || pressRectOffset === void 0 ? void 0 : pressRectOffset.left) !== null && _b !== void 0 ? _b : DEFAULT_PRESS_RECT_OFFSETS.left;
        regionRight += (_c = pressRectOffset === null || pressRectOffset === void 0 ? void 0 : pressRectOffset.right) !== null && _c !== void 0 ? _c : DEFAULT_PRESS_RECT_OFFSETS.right;
        regionTop -= (_d = pressRectOffset === null || pressRectOffset === void 0 ? void 0 : pressRectOffset.top) !== null && _d !== void 0 ? _d : DEFAULT_PRESS_RECT_OFFSETS.top;
        return touch.pageX > regionLeft && touch.pageX < regionRight && touch.pageY > regionTop && touch.pageY < regionBottom;
    };
    Pressability.prototype._handleLongPress = function (event) {
        if (this._touchState === 'RESPONDER_ACTIVE_PRESS_IN' || this._touchState === 'RESPONDER_ACTIVE_LONG_PRESS_IN') {
            this._receiveSignal('LONG_PRESS_DETECTED', event);
        }
    };
    Pressability.prototype._shouldLongPressCancelPress = function () {
        return true;
    };
    Pressability.prototype._cancelHoverInDelayTimeout = function () {
        if (this._hoverInDelayTimeout != null) {
            clearTimeout(this._hoverInDelayTimeout);
            this._hoverInDelayTimeout = null;
        }
    };
    Pressability.prototype._cancelHoverOutDelayTimeout = function () {
        if (this._hoverOutDelayTimeout != null) {
            clearTimeout(this._hoverOutDelayTimeout);
            this._hoverOutDelayTimeout = null;
        }
    };
    Pressability.prototype._cancelLongPressDelayTimeout = function () {
        if (this._longPressDelayTimeout != null) {
            clearTimeout(this._longPressDelayTimeout);
            this._longPressDelayTimeout = null;
        }
    };
    Pressability.prototype._cancelPressDelayTimeout = function () {
        if (this._pressDelayTimeout != null) {
            clearTimeout(this._pressDelayTimeout);
            this._pressDelayTimeout = null;
        }
    };
    Pressability.prototype._cancelPressOutDelayTimeout = function () {
        if (this._pressOutDelayTimeout != null) {
            clearTimeout(this._pressOutDelayTimeout);
            this._pressOutDelayTimeout = null;
        }
    };
    return Pressability;
}());
export { Pressability };
//# sourceMappingURL=Pressability.js.map