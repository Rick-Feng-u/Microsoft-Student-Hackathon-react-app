var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import { Platform } from 'react-native';
import { usePressability } from './usePressability';
/**
 * hover specific state and callback helper
 */
function useHoverHelper(props) {
    var _a = React.useState({ hovered: false }), hoverState = _a[0], setHoverState = _a[1];
    var onHoverIn = React.useCallback(function (e) {
        setHoverState({ hovered: true });
        if (props.onHoverIn) {
            props.onHoverIn(e);
        }
    }, [setHoverState, props.onHoverIn]);
    var onHoverOut = React.useCallback(function (e) {
        setHoverState({ hovered: false });
        if (props.onHoverOut) {
            props.onHoverOut(e);
        }
    }, [setHoverState, props.onHoverOut]);
    return [{ onHoverIn: onHoverIn, onHoverOut: onHoverOut }, hoverState];
}
/**
 * focus specific state and callback helper
 */
function useFocusHelper(props) {
    var _a = React.useState({ focused: false }), focusState = _a[0], setFocusState = _a[1];
    var onFocus = React.useCallback(function (e) {
        setFocusState({ focused: true });
        if (props.onFocus) {
            props.onFocus(e);
        }
    }, [setFocusState, props.onFocus]);
    var onBlur = React.useCallback(function (e) {
        setFocusState({ focused: false });
        if (props.onBlur) {
            props.onBlur(e);
        }
    }, [setFocusState, props.onBlur]);
    return [{ onFocus: onFocus, onBlur: onBlur }, focusState];
}
/**
 * press specific state and callback helper
 */
function usePressHelper(props) {
    var _a = React.useState({ pressed: false }), pressState = _a[0], setPressState = _a[1];
    var onPressIn = React.useCallback(function (e) {
        setPressState({ pressed: true });
        if (props.onPressIn) {
            props.onPressIn(e);
        }
    }, [setPressState, props.onPressIn]);
    var onPressOut = React.useCallback(function (e) {
        setPressState({ pressed: false });
        if (props.onPressOut) {
            props.onPressOut(e);
        }
    }, [setPressState, props.onPressOut]);
    return [{ onPressIn: onPressIn, onPressOut: onPressOut }, pressState];
}
/**
 * useAsPressable wraps the usePressability hook that will be available in RN 0.63 and beyond.  Once this library is on a recent enough
 * version of react-native this implementation can switch to using the official version.
 *
 * The useAsPressable hook adds a simple state change function for listening to hover, press, and focus events on the base pressability implementation
 * @param props - input props for the component, mixed in with pressable and pressability options
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export function useAsPressable(props) {
    var _a = useHoverHelper(props), hoverProps = _a[0], hoverState = _a[1];
    var _b = useFocusHelper(props), focusProps = _b[0], focusState = _b[1];
    var _c = usePressHelper(props), pressProps = _c[0], pressState = _c[1];
    var pressabilityProps = usePressability(__assign(__assign(__assign(__assign({}, props), hoverProps), focusProps), pressProps));
    return {
        props: __assign(__assign({}, props), pressabilityProps),
        state: __assign(__assign(__assign({}, hoverState), pressState), focusState),
    };
}
/**
 * A more focused version of useAsPressable, if only one state is needed.  Note that if two or more states are needed then useAsPressable is better
 * as each of these calls will create a new instance of the Pressability class.
 * @param props - input props for the component
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export function useFocusState(props) {
    var _a = useFocusHelper(props), focusProps = _a[0], focusState = _a[1];
    return [__assign(__assign({}, props), usePressability(__assign(__assign({}, props), focusProps))), focusState];
}
/**
 * A more focused version of useAsPressable, if only one state is needed.  Note that if two or more states are needed then useAsPressable is better
 * as each of these calls will create a new instance of the Pressability class.
 * @param props - input props for the component
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export function usePressState(props) {
    var _a = usePressHelper(props), pressProps = _a[0], pressState = _a[1];
    return [__assign(__assign({}, props), usePressability(__assign(__assign({}, props), pressProps))), pressState];
}
/**
 * A more focused version of useAsPressable, if only one state is needed.  Note that if two or more states are needed then useAsPressable is better
 * as each of these calls will create a new instance of the Pressability class.
 * @param props - input props for the component
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export function useHoverState(props) {
    var _a = useHoverHelper(props), hoverProps = _a[0], hoverState = _a[1];
    return [__assign(__assign({}, props), usePressability(__assign(__assign({}, props), hoverProps))), hoverState];
}
/**
 * This routine hooks the props to pass to a Pressable component to obtain the current state of the Pressable as well as generating
 * state change updates when those props change. This allows a parent component to control the render of the whole component rather than having
 * to split the code between a child function or style function.
 *
 * @param props - props to pass to a Pressable component
 * @returns - modified props to pass into the Pressable as well as the current state with regards to hover, focus, and press
 */
export function usePressableState(props) {
    var onPressIn = props.onPressIn, onPressOut = props.onPressOut, onHoverIn = props.onHoverIn, onHoverOut = props.onHoverOut, onFocus = props.onFocus, onBlur = props.onBlur, rest = __rest(props, ["onPressIn", "onPressOut", "onHoverIn", "onHoverOut", "onFocus", "onBlur"]);
    var _a = useFocusHelper({ onFocus: onFocus, onBlur: onBlur }), focusProps = _a[0], focusState = _a[1];
    var _b = usePressHelper({ onPressIn: onPressIn, onPressOut: onPressOut }), pressProps = _b[0], pressState = _b[1];
    var platformSupportsHover = Platform.OS !== 'android' && Platform.OS !== 'ios';
    var _c = platformSupportsHover ? useHoverHelper({ onHoverIn: onHoverIn, onHoverOut: onHoverOut }) : [{}, {}], hoverProps = _c[0], hoverState = _c[1];
    return { props: __assign(__assign(__assign(__assign({}, rest), focusProps), pressProps), hoverProps), state: __assign(__assign(__assign({}, focusState), pressState), hoverState) };
}
//# sourceMappingURL=useAsPressable.js.map