import { getCacheEntry } from './getCacheEntry';
/** base node used to remember references when a globalKey is set */
var _baseEntry = {};
/**
 * Primary functional worker used to implement the caching pattern
 *
 * @param entry - entry to use as the base of the cache traversal
 * @param factory - generally a function who's results will be cached, and returned via the set of keys
 * @param keys - an ordered array of values of any type, used as keys to look up the entry
 */
function getMemoValueWorker(entry, factory, keys) {
    var foundEntry = getCacheEntry(entry, keys);
    // check the key being set, not the value to disambiguate an undefined factory result/value from never having run the factory
    if (!foundEntry.hasOwnProperty('value')) {
        foundEntry.value = typeof factory === 'function' ? factory() : factory;
    }
    return [foundEntry.value, function (fact, args) { return getMemoValueWorker(foundEntry, fact, args); }];
}
/**
 * Get a memo cache instance, this can either be completely self-contained or associated with a global key
 *
 * @param globalKey - optional object reference to use as a key for this cache.  If specified it can be used
 * to retrieve the same cache from the global call.  If not specified the returned cache will be completely isolated.
 */
// eslint-disable-next-line @typescript-eslint/ban-types
export function getMemoCache(globalKey) {
    var entry = globalKey ? getCacheEntry(_baseEntry, [globalKey]) : {};
    return function (fact, args) { return getMemoValueWorker(entry, fact, args); };
}
//# sourceMappingURL=getMemoCache.js.map