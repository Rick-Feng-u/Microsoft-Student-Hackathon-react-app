import * as React from 'react';
import { ViewStyle, StyleProp } from 'react-native';
import { IViewProps } from '@fluentui-react-native/adapters';
import { IWithPressableOptions, IPressableState } from '@fluentui-react-native/interactive-hooks';
export declare type IPressableProps<TBase extends object = IViewProps> = IWithPressableOptions<TBase> & {
    children?: IRenderChild<IPressableState>;
    renderStyle?: IRenderStyle<IPressableState, ViewStyle>;
};
/**
 * Used by IRenderChild, it simply describes a function that takes
 * some generic state type T and returns a ReactNode
 */
export declare type IChildAsFunction<T> = (state: T) => React.ReactNode;
/**
 * An IRenderChild describes children as a function that take the current
 * state of the parent component. It is up to the parent to invoke the function
 * and make proper use of the more typical ReactNode object that is returned
 * This is an especially helpful construct when children of a Touchable require
 * knowledge of the interaction state of their parent to properly render themselves
 * (e.g. foreground color of a text child)
 */
export declare type IRenderChild<T> = IChildAsFunction<T> | React.ReactNode;
/**
 * An IRenderStyle describes style as a function that takes the current
 * state of the parent component. It is up to the parent to invoke the function
 * and make proper use of the more typical StyleProp<S> object that is returned
 * This is convenient for when styles need to be calculated depending on interaction states.
 */
export declare type IRenderStyle<T, S> = (state: T) => StyleProp<S>;
export declare type IPressableType<TBase extends object = IViewProps> = {
    props: IPressableProps<TBase>;
    slotProps: {
        root: TBase;
    };
};
//# sourceMappingURL=Pressable.props.d.ts.map