"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/** @jsx withSlots */
var React = __importStar(require("react"));
var react_native_1 = require("react-native");
var foundation_compose_1 = require("@uifabricshared/foundation-compose");
var foundation_composable_1 = require("@uifabricshared/foundation-composable");
var text_1 = require("@fluentui-react-native/text");
var icon_1 = require("@fluentui-react-native/icon");
var TabsItem_settings_1 = require("./TabsItem.settings");
var tokens_1 = require("@fluentui-react-native/tokens");
var adapters_1 = require("@fluentui-react-native/adapters");
var foundation_settings_1 = require("@uifabricshared/foundation-settings");
var Tabs_1 = require("./Tabs");
var TabsItem_types_1 = require("./TabsItem.types");
var interactive_hooks_1 = require("@fluentui-react-native/interactive-hooks");
exports.TabsItem = foundation_compose_1.compose({
    displayName: TabsItem_types_1.tabsItemName,
    usePrepareProps: function (userProps, useStyling) {
        var defaultComponentRef = React.useRef(null);
        var icon = userProps.icon, _a = userProps.headerText, headerText = _a === void 0 ? '' : _a, _b = userProps.accessibilityLabel, accessibilityLabel = _b === void 0 ? userProps.headerText : _b, _c = userProps.componentRef, componentRef = _c === void 0 ? defaultComponentRef : _c, testID = userProps.testID, itemKey = userProps.itemKey, itemCount = userProps.itemCount, accessibilityPositionInSet = userProps.accessibilityPositionInSet, accessibilitySetSize = userProps.accessibilitySetSize, rest = __rest(userProps, ["icon", "headerText", "accessibilityLabel", "componentRef", "testID", "itemKey", "itemCount", "accessibilityPositionInSet", "accessibilitySetSize"]);
        // Grabs the context information from Tabs (currently selected TabsItem and client's onTabsClick callback).
        var info = React.useContext(Tabs_1.TabsContext);
        var changeSelection = React.useCallback(function () {
            info.focusZoneRef.current.focus(); // GH #964, FocusZone not implemented on windows.
            info.onTabsClick && info.onTabsClick(itemKey);
            info.getTabId && info.getTabId(itemKey, info.tabsItemKeys.findIndex(function (x) { return x == itemKey; }) + 1);
            info.updateSelectedTabsItemRef && componentRef && info.updateSelectedTabsItemRef(componentRef);
        }, [componentRef, info, itemKey]);
        var pressable = interactive_hooks_1.useAsPressable(__assign(__assign({}, rest), { onPress: changeSelection }));
        // Set up state.
        var state = {
            info: __assign(__assign({}, pressable.state), { selected: info.selectedKey === userProps.itemKey, icon: false, key: itemKey, headerText: !!headerText || itemCount !== undefined }),
        };
        var buttonRef = interactive_hooks_1.useViewCommandFocus(componentRef);
        /* We use the componentRef of the currently selected tabsItem to maintain the default tabbable
        element in Tabs. Since the componentRef isn't generated until after initial render,
        we must update it once here. */
        React.useEffect(function () {
            if (itemKey == info.selectedKey) {
                info.updateSelectedTabsItemRef && componentRef && info.updateSelectedTabsItemRef(componentRef);
            }
        }, []);
        // Grab the styling information from the userProps, referencing the state as well as the props.
        var styleProps = useStyling(userProps, function (override) { return state.info[override] || userProps[override]; });
        // Used when creating accessibility properties in mergeSettings below.
        var onAccessibilityAction = React.useCallback(function (event) {
            switch (event.nativeEvent.actionName) {
                case 'Select':
                    changeSelection();
                    break;
            }
        }, [info, itemKey]);
        var countText = itemCount !== undefined ? " (" + itemCount + ")" : '';
        var slotProps = foundation_settings_1.mergeSettings(styleProps, {
            root: __assign(__assign(__assign({}, rest), pressable.props), { ref: buttonRef, accessibilityRole: 'tab', accessibilityLabel: accessibilityLabel, accessibilityState: { disabled: userProps.disabled, selected: info.selectedKey === userProps.itemKey }, accessibilityActions: [{ name: 'Select', label: TabsItem_settings_1.tabsItemSelectActionLabel }], accessibilityPositionInSet: accessibilityPositionInSet !== null && accessibilityPositionInSet !== void 0 ? accessibilityPositionInSet : info.tabsItemKeys.findIndex(function (x) { return x == itemKey; }) + 1, accessibilitySetSize: accessibilitySetSize !== null && accessibilitySetSize !== void 0 ? accessibilitySetSize : info.tabsItemKeys.length, onAccessibilityAction: onAccessibilityAction, focusable: false }),
            content: { children: headerText + countText, testID: testID },
            icon: interactive_hooks_1.createIconProps(icon),
        });
        return { slotProps: slotProps, state: state };
    },
    render: function (Slots, renderData) {
        var children = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            children[_i - 2] = arguments[_i];
        }
        var info = renderData.state.info;
        var context = React.useContext(Tabs_1.TabsContext);
        // Sets the view that belongs to a TabItem.
        context.views.set(info.key, children);
        return (foundation_composable_1.withSlots(Slots.root, null,
            foundation_composable_1.withSlots(Slots.stack, null,
                info.icon && foundation_composable_1.withSlots(Slots.icon, null),
                info.headerText && foundation_composable_1.withSlots(Slots.content, null)),
            foundation_composable_1.withSlots(Slots.indicator, null)));
    },
    settings: TabsItem_settings_1.settings,
    slots: {
        root: react_native_1.View,
        stack: { slotType: react_native_1.View, filter: adapters_1.filterViewProps },
        icon: { slotType: icon_1.Icon },
        content: text_1.Text,
        indicator: { slotType: react_native_1.View, filter: adapters_1.filterViewProps },
    },
    styles: {
        root: [tokens_1.backgroundColorTokens, tokens_1.borderTokens],
        stack: [],
        icon: [{ source: 'iconColor', lookup: tokens_1.getPaletteFromTheme, target: 'color' }],
        content: [tokens_1.textTokens, tokens_1.foregroundColorTokens],
        indicator: [{ source: 'indicatorColor', lookup: tokens_1.getPaletteFromTheme, target: 'backgroundColor' }],
    },
});
exports.default = exports.TabsItem;
//# sourceMappingURL=TabsItem.windows.js.map