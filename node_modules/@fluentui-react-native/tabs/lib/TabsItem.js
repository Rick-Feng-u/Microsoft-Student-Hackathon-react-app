var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
/** @jsx withSlots */
import * as React from 'react';
import { Platform, View } from 'react-native';
import { compose } from '@uifabricshared/foundation-compose';
import { withSlots } from '@uifabricshared/foundation-composable';
import { Text } from '@fluentui-react-native/text';
import { Icon } from '@fluentui-react-native/icon';
import { settings, tabsItemSelectActionLabel } from './TabsItem.settings';
import { backgroundColorTokens, borderTokens, textTokens, foregroundColorTokens, getPaletteFromTheme } from '@fluentui-react-native/tokens';
import { filterViewProps } from '@fluentui-react-native/adapters';
import { mergeSettings } from '@uifabricshared/foundation-settings';
import { TabsContext } from './Tabs';
import { tabsItemName } from './TabsItem.types';
import { useAsPressable, useViewCommandFocus, createIconProps } from '@fluentui-react-native/interactive-hooks';
export var TabsItem = compose({
    displayName: tabsItemName,
    usePrepareProps: function (userProps, useStyling) {
        var defaultComponentRef = React.useRef(null);
        var icon = userProps.icon, _a = userProps.headerText, headerText = _a === void 0 ? '' : _a, _b = userProps.accessibilityLabel, accessibilityLabel = _b === void 0 ? userProps.headerText : _b, _c = userProps.componentRef, componentRef = _c === void 0 ? defaultComponentRef : _c, testID = userProps.testID, itemKey = userProps.itemKey, itemCount = userProps.itemCount, accessibilityPositionInSet = userProps.accessibilityPositionInSet, accessibilitySetSize = userProps.accessibilitySetSize, rest = __rest(userProps, ["icon", "headerText", "accessibilityLabel", "componentRef", "testID", "itemKey", "itemCount", "accessibilityPositionInSet", "accessibilitySetSize"]);
        // Grabs the context information from Tabs (currently selected TabsItem and client's onTabsClick callback).
        var info = React.useContext(TabsContext);
        var _d = React.useState({
            focused: false,
        }), focusState = _d[0], setFocusState = _d[1];
        var changeSelection = React.useCallback(function () {
            var _a;
            (_a = componentRef === null || componentRef === void 0 ? void 0 : componentRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }, [componentRef]);
        var changeSelectionWithFocus = React.useCallback(function () {
            setFocusState({ focused: true });
            if (!focusState.focused) {
                info.onTabsClick && info.onTabsClick(itemKey);
                info.getTabId && info.getTabId(itemKey, info.tabsItemKeys.findIndex(function (x) { return x == itemKey; }) + 1);
                info.updateSelectedTabsItemRef && componentRef && info.updateSelectedTabsItemRef(componentRef);
            }
        }, [focusState, setFocusState, componentRef, info, itemKey]);
        var removeFocus = React.useCallback(function () {
            setFocusState({ focused: false });
        }, [setFocusState]);
        var pressable = useAsPressable(__assign(__assign({}, rest), { onPress: changeSelection, onFocus: changeSelectionWithFocus, onBlur: removeFocus }));
        // Set up state.
        var state = {
            info: __assign(__assign({}, pressable.state), { selected: info.selectedKey === userProps.itemKey, icon: !!icon, key: itemKey, headerText: !!headerText || itemCount !== undefined }),
        };
        var buttonRef = Platform.OS === 'macos' ? componentRef : useViewCommandFocus(componentRef);
        /* We use the componentRef of the currently selected tabsItem to maintain the default tabbable
        element in Tabs. Since the componentRef isn't generated until after initial render,
        we must update it once here. */
        React.useEffect(function () {
            if (itemKey == info.selectedKey) {
                info.updateSelectedTabsItemRef && componentRef && info.updateSelectedTabsItemRef(componentRef);
            }
        }, []);
        // Grab the styling information from the userProps, referencing the state as well as the props.
        var styleProps = useStyling(userProps, function (override) { return state.info[override] || userProps[override]; });
        // Used when creating accessibility properties in mergeSettings below.
        var onAccessibilityAction = React.useCallback(function (event) {
            switch (event.nativeEvent.actionName) {
                case 'Select':
                    changeSelection();
                    break;
            }
        }, [info, itemKey]);
        var countText = itemCount !== undefined ? " (" + itemCount + ")" : '';
        var slotProps = mergeSettings(styleProps, {
            root: __assign(__assign(__assign({}, rest), pressable.props), { ref: buttonRef, accessibilityRole: 'tab', accessibilityLabel: accessibilityLabel, accessibilityState: { disabled: userProps.disabled, selected: info.selectedKey === userProps.itemKey }, accessibilityActions: [{ name: 'Select', label: tabsItemSelectActionLabel }], accessibilityPositionInSet: accessibilityPositionInSet !== null && accessibilityPositionInSet !== void 0 ? accessibilityPositionInSet : info.tabsItemKeys.findIndex(function (x) { return x == itemKey; }) + 1, accessibilitySetSize: accessibilitySetSize !== null && accessibilitySetSize !== void 0 ? accessibilitySetSize : info.tabsItemKeys.length, onAccessibilityAction: onAccessibilityAction, focusable: Platform.select({ default: true, macos: !userProps.disabled }) }),
            content: { children: headerText + countText, testID: testID },
            icon: createIconProps(icon),
        });
        return { slotProps: slotProps, state: state };
    },
    render: function (Slots, renderData) {
        var children = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            children[_i - 2] = arguments[_i];
        }
        var info = renderData.state.info;
        var context = React.useContext(TabsContext);
        // Sets the view that belongs to a TabItem.
        context.views.set(info.key, children);
        return (withSlots(Slots.root, null,
            withSlots(Slots.stack, null,
                info.icon && withSlots(Slots.icon, null),
                info.headerText && withSlots(Slots.content, null)),
            withSlots(Slots.indicator, null)));
    },
    settings: settings,
    slots: {
        root: View,
        stack: { slotType: View, filter: filterViewProps },
        icon: { slotType: Icon },
        content: Text,
        indicator: { slotType: View, filter: filterViewProps },
    },
    styles: {
        root: [backgroundColorTokens, borderTokens],
        stack: [],
        icon: [{ source: 'iconColor', lookup: getPaletteFromTheme, target: 'color' }],
        content: [textTokens, foregroundColorTokens],
        indicator: [{ source: 'indicatorColor', lookup: getPaletteFromTheme, target: 'backgroundColor' }],
    },
});
export default TabsItem;
//# sourceMappingURL=TabsItem.js.map