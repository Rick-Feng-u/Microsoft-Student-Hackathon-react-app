"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mergeTheme_1 = require("./mergeTheme");
/**
 * Provides a wrapper around a theme object, allowing the ability to create a theme from another theme, to listen to theme
 * changes, and to update the theme.
 *
 * This is the object that is designed to be handed to a theme provider, such that it can listen for changes and set the
 * value into context again.
 */
var ThemeReference = /** @class */ (function () {
    /**
     * Create the theme reference, either as a plain wrapper, or a wrapper with additional transforms and/or merging
     * @param base - can be either another ThemeReference object, or a fully specified theme
     * @param recipes - any number of recipes to be applied on top of the theme object
     */
    function ThemeReference(base) {
        var _this = this;
        var recipes = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            recipes[_i - 1] = arguments[_i];
        }
        this.themeData = undefined;
        this.listeners = [];
        this.parentRef = undefined;
        this.listeners = [];
        this.recipes = recipes;
        this.parentRef = base instanceof ThemeReference ? base : undefined;
        if (this.parentRef) {
            var onChanged = function () {
                _this.invalidate();
            };
            this.parentRef.addOnThemeChanged(onChanged);
        }
        this.getParent = function () { return (_this.parentRef ? _this.parentRef.theme : base); };
    }
    Object.defineProperty(ThemeReference.prototype, "theme", {
        /**
         * get the internal theme object, which will be created on-demand
         */
        get: function () {
            if (!this.themeData) {
                var theme = this.getParent();
                for (var _i = 0, _a = this.recipes; _i < _a.length; _i++) {
                    var recipe = _a[_i];
                    theme = mergeTheme_1.mergeTheme(theme, typeof recipe === 'function' ? recipe(theme) : recipe);
                }
                this.themeData = theme;
            }
            return this.themeData;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * register a new listener for theme changes
     */
    ThemeReference.prototype.addOnThemeChanged = function (listener) {
        this.listeners.push(listener);
    };
    /**
     * remove a previously registered listener
     */
    ThemeReference.prototype.removeOnThemeChanged = function (listener) {
        this.listeners = this.listeners.filter(function (v) { return v !== listener; });
    };
    /**
     * invalidate the theme, causing it to be regenerated. This can happen via notifications from the parent, but
     * can also be called directly if a functional transform needs to be re-run
     */
    ThemeReference.prototype.invalidate = function () {
        this.themeData = undefined;
        for (var _i = 0, _a = this.listeners; _i < _a.length; _i++) {
            var listener = _a[_i];
            listener();
        }
    };
    /**
     * update the recipes (but not the base) in the theme. This will also implicitly invalidate the theme
     * since the recipes changed.
     */
    ThemeReference.prototype.update = function () {
        var recipes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            recipes[_i] = arguments[_i];
        }
        this.recipes = recipes || [];
        this.invalidate();
    };
    return ThemeReference;
}());
exports.ThemeReference = ThemeReference;
//# sourceMappingURL=themeReference.js.map