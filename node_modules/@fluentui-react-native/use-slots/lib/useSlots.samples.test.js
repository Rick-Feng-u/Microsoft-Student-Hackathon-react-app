var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
/** @jsx withSlots */
import { withSlots, stagedComponent } from '@fluentui-react-native/use-slot';
import { mergeProps } from '@fluentui-react-native/merge-props';
import { buildUseSlots } from './buildUseSlots';
import toJson from 'enzyme-to-json';
import { mount } from 'enzyme';
/**
 * This file contains samples and description to help explain what the useSlots hook does and why it is useful
 * for building components.
 */
describe('useSlots sample code test suite', function () {
    /**
     * The first mechanism to understand is the stagedComponent mechanic. This allows a component to be written, separating
     * hook calls and component rendering. This allows it to be safely called as a function by a higher order component, even conditionally.
     */
    /**
     * Example #1: Single level simple component ----------------------------------------
     *
     * First we are going to create a wrapped text component that bolds all text. One component will be authored as a staged
     * component and one as a regular component.
     */
    var boldBaseProps = { style: { fontWeight: 900 } };
    /**
     * First create the bold text in the standard way. This is just a function component.
     */
    var BoldTextStandard = function (props) {
        /**
         * Pick out the children to pass them on to the child Text element
         */
        var children = props.children, rest = __rest(props, ["children"]);
        /**
         * Now render the text, merging the baseProps with the style updates with the rest param. Note that this leverages the fact
         * that mergeProps will reliably produce style objects with the same reference, given the same inputs.
         */
        return withSlots("span", __assign({}, mergeProps(boldBaseProps, rest)), children);
    };
    BoldTextStandard.displayName = 'BoldTextStandard';
    /**
     * To write the same component using the staged pattern is only slightly more complex. The pattern involves splitting the component rendering into
     * two parts and executing any hooks in the first part.
     *
     * The stagedComponent function takes an input function of this form and wraps it in a function component that react knows how to render
     */
    var BoldTextStaged = stagedComponent(function (props) {
        /**
         * This section would be where hook/styling code would go, props here would include everything coming in from the base react tree with the
         * exception of children, which will be passed in stage 2.
         */
        return function (extra, children) {
            /**
             * extra are additional props that may be filled in by a higher order component. They should not include styling and are only props the
             * enclosing component are passing to the JSX elements
             */
            return withSlots("span", __assign({}, mergeProps(boldBaseProps, props, extra)), children);
        };
    });
    BoldTextStaged.displayName = 'BoldTextStaged';
    /**
     * The demos of the code use enzyme with JSDom to show the full tree. This has the side effect of doubling up primitive elements in the output
     * JSON. This is an issue with rendering react-native with enzyme but in real usage the nodes only render once.
     */
    it('renders sample 1 - the two types of basic bold text components', function () {
        var styleToMerge = { color: 'black' };
        /**
         * First render the staged component. This invokes the wrapper that was built by the stagedComponent function
         */
        var wrapper = mount(withSlots("div", null,
            withSlots(BoldTextStaged, { style: styleToMerge }, "Staged component at one level"),
            withSlots(BoldTextStandard, { style: styleToMerge }, "Standard component of a single level")));
        expect(toJson(wrapper)).toMatchSnapshot();
    });
    /**
     * Example #2 - Simple component containing another simple component -------------------------------------
     *
     * Next we will build a layer on top of the previously authored components to turn the bold text components into header components. This is
     * to illustrate the way in which components can be commonly built on top of other simpler components.
     */
    var headerBaseProps = { style: { fontSize: 20 } };
    /**
     * The standard way of doing things is a repeat of what happens above. Grab the children, pass them on, merge the rest of the props with
     * base props.
     *
     * This again leverages style merging via mergeProps to avoid changing the references of the style objects on every render
     */
    var HeaderStandard = function (props) {
        var children = props.children, rest = __rest(props, ["children"]);
        return withSlots(BoldTextStandard, __assign({}, mergeProps(headerBaseProps, rest)), children);
    };
    HeaderStandard.displayName = 'HeaderStandard';
    /**
     * To consume the staged component we'll use the use slots hook builder. This allows easy consumption of staged components (or standard components)
     * This will be described in more detail further on but in this case the component has a single child component, so it only has one slot that we
     * will call 'text'
     *
     * This should be built once, and consumed by the component, not built on the fly inside
     */
    var useHeaderSlots = buildUseSlots({ slots: { text: BoldTextStaged } });
    /**
     * Now author the staged component using the slot hook
     */
    var HeaderStaged = stagedComponent(function (props) {
        /**
         * Call the slots hook (or any hook) outside of the inner closure. The useSlots hook will return an object with each slot as a renderable
         * function. The hooks for sub-components will be called as part of this call. Props passed in at this point will be the props that appear
         * in outer part of the staged component. (For this example `props`)
         *
         * Note that while we are passing in props, in the simple usage case it isn't used and could be omitted if desired
         * */
        var BoldText = useHeaderSlots(props).text;
        /** Now the inner closure, pretty much the same as before */
        return function (extra, children) {
            /**
             * Instead of rendering the <BoldTextStageed> component directly we render using the slot. If this is a staged component it will call the
             * inner closure directly, without going through createElement. Entries passed into the JSX, including children, are what appear in the
             * props of the inner closure. (In this example `extra`)
             *
             * NOTE: this requires using the withSlots helper via the jsx directive. This knows how to pick apart the entries and just call the second
             * part of the function
             */
            return withSlots(BoldText, __assign({}, mergeProps(headerBaseProps, props, extra)), children);
        };
    });
    HeaderStaged.displayName = 'HeaderStaged';
    /**
     * Look at the snapshots to compare the rendered output. The staged component will skip the intermediate levels of the react hieararchy while
     * still rendering to the correct primitives.
     */
    it('renders sample 2 = the two types of two level header components', function () {
        var styleToMerge = { color: 'black' };
        /**
         * First render the staged component. This invokes the wrapper that was built by the stagedComponent function
         */
        var wrapper = mount(withSlots("div", null,
            withSlots(HeaderStaged, { style: styleToMerge }, "Staged component with two levels"),
            withSlots(HeaderStandard, { style: styleToMerge }, "Standard component with two levels")));
        expect(toJson(wrapper)).toMatchSnapshot();
    });
    /** standard props for the container */
    var containerProps = { style: { display: 'flex', flexDirection: 'column' } };
    /**
     * add a quick cache to ensure that we don't thrash the styles. This is a danger any time a value from a style is added as
     * a prop on a component
     */
    var colorProps = {};
    var getColorProps = function (value) {
        if (value !== undefined) {
            colorProps[value] = colorProps[value] || { style: { color: value } };
            return colorProps[value];
        }
        return {};
    };
    /**
     * now just create the component like a standard react functional component
     */
    var CaptionedHeaderStandard = function (props) {
        var headerColor = props.headerColor, captionColor = props.captionColor, captionText = props.captionText, children = props.children, rest = __rest(props, ["headerColor", "captionColor", "captionText", "children"]);
        var headerColorProps = getColorProps(headerColor);
        var captionColorProps = getColorProps(captionColor);
        return (withSlots("div", __assign({}, mergeProps(containerProps, rest)),
            withSlots(HeaderStandard, __assign({}, headerColorProps), children),
            captionText && withSlots(BoldTextStandard, __assign({}, captionColorProps), captionText)));
    };
    CaptionedHeaderStandard.displayName = "CaptionedHeaderStandard';";
    /**
     * now build the same component using slots hook. This will also add use of the style injection pattern
     */
    var useCaptionedHeaderSlots = buildUseSlots({
        /** Slots are just like above, this component will have three sub-components */
        slots: {
            container: 'div',
            header: HeaderStaged,
            caption: BoldTextStaged,
        },
        /** useStyling is an optional function that turns props into props for the sub-components */
        useStyling: function (props) { return ({
            container: containerProps,
            header: getColorProps(props.headerColor),
            caption: getColorProps(props.captionColor),
        }); },
    });
    /** a mask to clear props that we don't want to pass to the inner view */
    var clearCustomProps = { headerColor: undefined, captionColor: undefined };
    /**
     * now use the hook to implement it as a staged component
     */
    var CaptionedHeaderStaged = stagedComponent(function (props) {
        // At the point where this is called the slots are initialized with the initial prop values from useStyling above
        var Slots = useCaptionedHeaderSlots(props);
        return function (extra, children) {
            // merge the props together, picking out the caption text and clearing any custom values we don't want forwarded to the view
            var _a = mergeProps(props, extra, clearCustomProps), captionText = _a.captionText, rest = __rest(_a, ["captionText"]);
            // now render using the slots. Any values passed in via JSX will be merged with values from the slot hook above
            return (withSlots(Slots.container, __assign({}, rest),
                withSlots(Slots.header, null, children),
                captionText && withSlots(Slots.caption, null, captionText)));
        };
    });
    CaptionedHeaderStaged.displayName = 'CaptionedHeaderStaged';
    /**
     * Render to enzyme snapshots
     */
    it('renders sample 3 - the two types of higher order header components', function () {
        var styleToMerge = { backgroundColor: 'gray', borderColor: 'purple', borderWidth: 1 };
        /**
         * Render the two sets of components. Note in the snapshots how the render tree layers for the standard approach are starting
         * to add up.
         */
        var wrapper = mount(withSlots("div", null,
            withSlots("span", null, "--- SIMPLE USAGE COMPARISON ---"),
            withSlots(CaptionedHeaderStandard, { style: styleToMerge }, "Standard HOC"),
            withSlots(CaptionedHeaderStaged, { style: styleToMerge }, "Staged HOC"),
            withSlots("span", null, "--- COMPARISON WITH CAPTIONS ---"),
            withSlots(CaptionedHeaderStandard, { style: styleToMerge, captionText: "Caption text" }, "Standard HOC with Caption"),
            withSlots(CaptionedHeaderStaged, { style: styleToMerge, captionText: "Caption text" }, "Staged HOC with Caption"),
            withSlots("span", null, "--- COMPARISON WITH CAPTIONS AND CUSTOMIZATIONS ---"),
            withSlots(CaptionedHeaderStandard, { style: styleToMerge, captionText: "Caption text", captionColor: "yellow", headerColor: "red" }, "Standard HOC with caption and customizations"),
            withSlots(CaptionedHeaderStaged, { style: styleToMerge, captionText: "Caption text", captionColor: "yellow", headerColor: "red" }, "Staged HOC with caption and customizations")));
        expect(toJson(wrapper)).toMatchSnapshot();
    });
});
//# sourceMappingURL=useSlots.samples.test.js.map