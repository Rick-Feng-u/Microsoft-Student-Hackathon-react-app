import { GetMemoValue } from '@fluentui-react-native/memo-cache';
/**
 * Informs the framework of any tokens that also appear as props for the component.
 * - 'none' | undefined : this means no properties should be treated as tokens, the tokens that will be passed in to buildProps
 *                        will not be patched from props. This also means that for a given theme + state the tokens will not
 *                        change. As a result this is the most efficient mode.
 * - 'all'              : treat all props as tokens. Props will be spread into the tokens before the slot functions are called
 * - array of keys      : this is the discrete list of tokens which also appear in props
 */
export declare type TokensThatAreAlsoProps<TTokens> = (keyof TTokens)[] | 'all' | 'none';
/**
 * Raw format for producing styles in a functional manner. These can only depend on tokens or theme as inputs.
 * - tokens:  these will be produced from the theme and component constants, then they will be potentially
 *            be modified by the props. See the TokensThatAreAlsoProps type for more details.
 * - theme:   the theme is provided for reference
 * The provided
 * cache will be scoped to the theme, slot, and tokens that are coming out of the theme.
 */
export declare type BuildPropsBase<TProps, TTokens, TTheme, TOuterProps> = (tokens: TTokens, theme: TTheme, props: TOuterProps, cache: GetMemoValue<any>) => Partial<TProps>;
/**
 * A refine function allows style functions to be updated based on tokens that are also props. Only those tokens that are also
 * props need to be considered as a key for caching
 */
export declare type RefineFunctionBase<TProps, TTokens, TTheme, TOuterProps> = (mask?: TokensThatAreAlsoProps<TTokens>) => BuildPropsBase<TProps, TTokens, TTheme, TOuterProps>;
/**
 * Signature for a style function which can be optionally refined by the styling hook if prop masks are provided
 */
export declare type RefinableBuildPropsBase<TProps, TTokens, TTheme, TOuterProps> = BuildPropsBase<TProps, TTokens, TTheme, TOuterProps> & {
    refine?: RefineFunctionBase<TProps, TTokens, TTheme, TOuterProps>;
};
/**
 * Style functions can be plain functions, refinable functions, or just raw props
 */
export declare type BuildSlotProps<TSlotProps, TTokens, TTheme, TOuterProps> = {
    [K in keyof TSlotProps]?: RefinableBuildPropsBase<TSlotProps[K], TTokens, TTheme, TOuterProps> | TSlotProps[K];
};
/**
 * Standard wrapper for a function that provides props for a component based on tokens and theme.
 *
 * @param fn - function which does the work of producing props for the tokens, theme, and props provided
 * @param keys - which token and prop properties are used by this style, this determines the keys to use for caching
 */
export declare function buildProps<TProps, TTokens, TTheme, TOuterProps = unknown>(fn: (tokens: TTokens, theme: TTheme, props?: TOuterProps) => TProps, keys?: (keyof TTokens | keyof TOuterProps)[]): RefinableBuildPropsBase<TProps, TTokens, TTheme, TOuterProps>;
/**
 * Utility function to check the type and refinement capabilities of a styleFunction and refine it if appropriate
 *
 * @param fn - function or props to potentially refine
 * @param mask - prop mask to use for refinement
 */
export declare function refinePropsFunctions<TSlotProps, TTokens, TTheme, TOuterProps>(styles: BuildSlotProps<TSlotProps, TTokens, TTheme, TOuterProps>, mask: TokensThatAreAlsoProps<TTokens>): BuildSlotProps<TSlotProps, TTokens, TTheme, TOuterProps>;
//# sourceMappingURL=buildProps.d.ts.map