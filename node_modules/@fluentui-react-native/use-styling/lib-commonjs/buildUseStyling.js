"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var buildProps_1 = require("./buildProps");
var use_tokens_1 = require("@fluentui-react-native/use-tokens");
/**
 * Produce the final slot props for the styled hook
 *
 * @param styles - refined style functions or props to use for processing
 * @param tokens - token inputs for the style functions
 * @param theme - theme to resolve against
 * @param props - props from outer component
 * @param cache - cache to use for the base of slot caching
 */
function resolveToSlotProps(styles, tokens, theme, props, cache) {
    var slotProps = {};
    Object.keys(styles).forEach(function (key) {
        var style = styles[key];
        slotProps[key] = typeof style === 'function' ? style(tokens, theme, props, cache(null, [key])[1]) : style;
    });
    return slotProps;
}
/**
 * Construct a useStyling hook which returns styled slot props based on props and tokens defined in options and in the theme
 *
 * @param options - options which drive behavior for the generated styling hook
 * @param themeHelper - injected theme functionality
 */
function buildUseStyling(options, themeHelper) {
    // create a cache instance for this use styling implementation
    var useTheme = themeHelper.useTheme, getComponentInfo = themeHelper.getComponentInfo;
    var tokens = options.tokens, tokenProps = options.tokensThatAreAlsoProps;
    var styles = buildProps_1.refinePropsFunctions(options.slotProps || {}, tokenProps);
    var useTokens = use_tokens_1.buildUseTokens.apply(void 0, __spreadArrays([getComponentInfo], tokens));
    return function (props, lookup) {
        var _a, _b;
        // query the theme
        var theme = useTheme();
        // get the merged tokens from the theme
        var _c = useTokens(theme), mergedTokens = _c[0], cache = _c[1];
        // resolve overrides as appropriate
        if (options.states) {
            _a = use_tokens_1.applyTokenLayers(mergedTokens, options.states, cache, lookup || (function (val) { return props[val]; })), mergedTokens = _a[0], cache = _a[1];
        }
        // now resolve tokens
        if (typeof tokenProps === 'object' && Array.isArray(tokenProps)) {
            _b = use_tokens_1.applyPropsToTokens(props, mergedTokens, cache, tokenProps), mergedTokens = _b[0], cache = _b[1];
        }
        else if (tokenProps === 'all') {
            mergedTokens = __assign(__assign({}, mergedTokens), props);
        }
        // finally produce slotProps from calling the style functions on each entry
        return resolveToSlotProps(styles, mergedTokens, theme, props, cache);
    };
}
exports.buildUseStyling = buildUseStyling;
//# sourceMappingURL=buildUseStyling.js.map