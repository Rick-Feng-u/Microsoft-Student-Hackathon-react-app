/**
 * Caches and returns the function based on the current keys.
 *
 * @param fn Function which does the work of producing props for the tokens, theme, and props provided
 * @param keys Set of input values the function is dependent on
 * @returns Cached function
 */
function cacheStyleClosure(fn, keys) {
    return function (tokens, theme, props, cache) {
        return cache(function () { return fn(tokens, theme, props); }, (keys || []).map(function (key) {
            if (Object.keys(tokens).includes(key)) {
                return tokens[key];
            }
            else {
                return props[key];
            }
        }))[0];
    };
}
/**
 * Reduce keys to the set that are also part of the mask.
 *
 * @param keys - which token and prop properties are used by this style, this determines the keys to use for caching
 * @param mask - the set of tokens that are also props
 * @returns An array of keys that are part of the mask to be used as a caching key
 */
function refineKeys(keys, mask) {
    return typeof mask === 'object' && Array.isArray(mask) ? keys.filter(function (key) { return mask.findIndex(function (val) { return val === key; }) !== -1; }) : mask ? keys : [];
}
/**
 * Standard wrapper for a function that provides props for a component based on tokens and theme.
 *
 * @param fn - function which does the work of producing props for the tokens, theme, and props provided
 * @param keys - which token and prop properties are used by this style, this determines the keys to use for caching
 */
export function buildProps(fn, keys) {
    // wrap the provided function in the standard caching layer, basing it upon the provided keys
    var result = cacheStyleClosure(fn, keys);
    // if results are being cached on keys, provide the ability to refine the function if a prop mask is specified
    result.refine =
        keys && keys.length > 0
            ? function (mask) {
                return cacheStyleClosure(fn, refineKeys(keys, mask));
            }
            : undefined;
    // return the style function decorated with the refine function
    return result;
}
/**
 * Utility function to check the type and refinement capabilities of a styleFunction and refine it if appropriate
 *
 * @param fn - function or props to potentially refine
 * @param mask - prop mask to use for refinement
 */
export function refinePropsFunctions(styles, mask) {
    var result = {};
    Object.keys(styles).forEach(function (key) {
        var refine = typeof styles[key] === 'function' &&
            styles[key].refine;
        result[key] = refine ? refine(mask) : styles[key];
    });
    return result;
}
//# sourceMappingURL=buildProps.js.map