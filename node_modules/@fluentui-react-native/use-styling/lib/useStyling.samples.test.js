var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import { buildUseStyling } from './buildUseStyling';
import { Text, View } from 'react-native';
import { buildProps } from './buildProps';
import toJson from 'enzyme-to-json';
import * as React from 'react';
import { mount } from 'enzyme';
/**
 * The default/base theme just contains base values
 */
var baseTheme = {
    globals: {
        backgroundColor: 'white',
        color: 'black',
        borderColor: 'blue',
        fontFamily: 'Arial',
        fontSize: 12,
    },
    components: {},
};
var current = { theme: baseTheme };
/**
 * this wrapper solves the (so-far) inexplicable type errors from the matchers in typescript
 */
function snapshotTestTree(tree) {
    expect(toJson(tree)).toMatchSnapshot();
}
/**
 * Because the buildUseStyling utility is not opinionated about theming, the theming is injected via
 * a theme helper implementation. This allows for a framework to build an opinionated version with
 * whatever system they desire
 */
var themeHelper = {
    useTheme: function () { return current.theme; },
    getComponentInfo: function (theme, name) { return theme.components[name]; },
    setActive: function (theme) {
        current.theme = theme ? __assign(__assign({}, baseTheme), theme) : baseTheme;
    },
};
describe('useStyling samples', function () {
    /**
     * Sample #1 - Themeable text element
     *
     * This adds some default opinions for how a text element should be styled but only allows for customization
     * via theming
     */
    // now create the styling hook, first the options so they can be reused later
    var sample1StylingOptions = {
        /**
         * tell the styling hook how to build up the tokens
         */
        tokens: [
            /** first the default values should come from the global theme section */
            function (t) { return ({
                color: t.globals.color,
                fontFamily: t.globals.fontFamily,
                fontSize: t.globals.fontSize,
            }); },
            /** next we should look for a component reference to overlay */
            'Sample1',
        ],
        /**
         * Now provide the recipe for how to build props for the sub-components given the tokens
         */
        slotProps: {
            /** only one sub-component, a Text element called content, as a result this needs to build up TextProps */
            content: buildProps(
            /**
             * first input for buildProps is a function which takes tokens and a theme and returns props
             */
            function (tokens /*, theme: Theme */) {
                return {
                    style: __assign({}, tokens),
                };
            }, 
            /**
             * The second input are the tokens used as inputs for the above function. This is similar to the way the useEffect hook
             * works in react.
             */
            ['color', 'fontFamily', 'fontSize']),
        },
    };
    // now build the actual hook from the options and theme helper
    var useStylingSample1 = buildUseStyling(sample1StylingOptions, themeHelper);
    // now the sample 1 component becomes simple to build, just merge the styled props with the input props
    var Sample1Text = function (props) {
        var styledProps = useStylingSample1(props).content;
        var merged = __assign(__assign({}, props), styledProps);
        return React.createElement(Text, __assign({}, merged), props.children);
    };
    /** first render the component with no updates */
    it('Sample1Text rendering with no overrides', function () {
        var tree = mount(React.createElement(Sample1Text, null, "Sample1a"));
        snapshotTestTree(tree);
    });
    /** now re-theme the component via the components in the theme */
    it('Sample1Text rendering with some custom settings in the theme', function () {
        themeHelper.setActive({
            components: {
                Sample1: {
                    color: 'pink',
                    fontSize: 24,
                },
            },
        });
        var tree = mount(React.createElement(Sample1Text, null, "Sample1b"));
        snapshotTestTree(tree);
    });
    /**
     * Build the styling hook for sample2. Because this isn't being recombined this is being specified inline rather
     * than using a separate options object. Both are fine.
     */
    var useStylingSample2 = buildUseStyling(__assign(__assign({}, sample1StylingOptions), { 
        /**
         * In sample1 tokens are set to defaults from the global theme section, then patched with any values looked up with
         * the string 'Sample1'
         *
         * We want to maintain the logic of setting up the globals, but add an additional lookup for 'Sample2'. This might correspond
         * to saying that if we were making a variant of a 'Text' component called 'HeaderText', we might want to look up
         * customizations from 'Text' first, then override those customizations with those from 'HeaderText'
         *
         * If we didn't want to add the extra 'Sample2' lookup this line would be omitted. If we didn't want to look up 'Sample1' first
         * that could be filtered out of the array that is being copied
         */
        tokens: __spreadArrays(sample1StylingOptions.tokens, ['Sample2']), 
        /**
         * This is the final bit of magic. The tokens will already have values set from the global theme, they will then be patched with
         * any customizations set into Sample1 and/or Sample2.
         *
         * If this value was omitted then the tokens would be passed to the slotProps recipies as is. To have those values patched from
         * the component props we add a list of the props which need to be passed into tokens. If all props should be spread into the
         * tokens then this value can be set to 'all'. If none should be passed it can be omitted or set to 'none'
         */
        tokensThatAreAlsoProps: ['color'] }), themeHelper);
    // the Sample2Text component is built the same way as sample1, just using the new hook that has been created
    var Sample2Text = function (props) {
        var styledProps = useStylingSample2(props).content;
        var merged = __assign(__assign({}, props), styledProps);
        // delete the color key to not pass it through to the text props, could be done via destructuring, filtering, or any number of ways
        delete merged.color;
        // render the text
        return React.createElement(Text, __assign({}, merged), props.children);
    };
    /** rendering the Sample2 component with the base theme */
    it('Sample2Text rendering with defaults and a color override', function () {
        themeHelper.setActive();
        var tree = mount(React.createElement(View, null,
            React.createElement(Sample2Text, null, "Sample2 with defaults"),
            React.createElement(Sample2Text, { color: "green" }, "Sample2 with color override via prop")));
        snapshotTestTree(tree);
    });
    /** now re-theme the component via the components in the theme */
    it('Sample2Text rendering with some custom settings in the theme', function () {
        themeHelper.setActive({
            components: {
                Sample1: {
                    color: 'pink',
                    fontSize: 24,
                },
                Sample2: {
                    fontSize: 18,
                    fontFamily: 'Helvetica',
                },
            },
        });
        var tree = mount(React.createElement(View, null,
            React.createElement(Sample2Text, null, "Sample2 with theme overrides set"),
            React.createElement(Sample2Text, { color: "purple" }, "Sample2 with theme and color prop override")));
        snapshotTestTree(tree);
    });
});
//# sourceMappingURL=useStyling.samples.test.js.map