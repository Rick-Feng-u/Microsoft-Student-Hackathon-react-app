"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var immutable_merge_1 = require("@fluentui-react-native/immutable-merge");
/**
 * Apply token layers, building them up applied layer by applied layer, using the cache to store intermediate
 * values
 *
 * @param tokens - input tokens which may have layers to apply
 * @param states - array of states to check for, ordered by precedence
 * @param subCache - cache scoped to the root object with no layers applied
 * @param hasLayer - a function which returns whether a given layer should be applied
 */
function applyTokenLayers(tokens, states, subCache, hasLayer) {
    var final = { tokens: tokens, subCache: subCache };
    if (states && states.length > 0) {
        // now walk the overrides that are set, merging in props, caching results, and getting a new sub cache
        final = states
            .filter(function (val) { return hasLayer(val); })
            .reduce(function (previous, layerName) {
            var layer = previous.tokens[layerName];
            var _a = previous.subCache(function () { return (layer && typeof layer === 'object' ? immutable_merge_1.immutableMerge(previous.tokens, layer) : previous.tokens); }, [layer]), tokens = _a[0], subCache = _a[1];
            return { tokens: tokens, subCache: subCache };
        }, final);
    }
    return [final.tokens, final.subCache];
}
exports.applyTokenLayers = applyTokenLayers;
//# sourceMappingURL=applyTokenLayers.js.map