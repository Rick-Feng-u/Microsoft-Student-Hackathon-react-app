"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var memo_cache_1 = require("@fluentui-react-native/memo-cache");
var immutable_merge_1 = require("@fluentui-react-native/immutable-merge");
/**
 * Tokens are defined as either:
 *   TTokens     - an object
 *   string      - a name to look up in the theme
 *   function    - a function to run against the theme to produce tokens
 *
 * This function maps any of these types into a specific TTokens object.  A string is first lookup up in the theme, returning a function
 * or object. If the type is a function this will be invoked with the theme to generate the tokens object.
 *
 * @param tokenEntry - token entry to start with
 * @param theme - theme to use for queries
 * @param getComponentInfo - helper to use to lookup the component in the theme
 */
function mapToTokens(tokenEntry, theme, getComponentInfo) {
    if (typeof tokenEntry === 'string') {
        tokenEntry = (getComponentInfo && getComponentInfo(theme, tokenEntry)) || {};
    }
    if (typeof tokenEntry === 'function') {
        tokenEntry = tokenEntry(theme);
    }
    return tokenEntry;
}
/**
 * Construct a useStyling hook which returns styled slot props based on props and tokens defined in options and in the theme
 *
 * @param options - options which drive behavior for the generated styling hook
 * @param themeHelper - injected theme functionality
 */
function buildUseTokens(getComponentInfo) {
    var tokens = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        tokens[_i - 1] = arguments[_i];
    }
    // create a cache instance for use in this particular call to buildUseTokens
    var cache = memo_cache_1.getMemoCache();
    // the core function simply merges layers together, looking up component definitions in the theme as well as executing any
    // theme functions. This turns the tokens into an array of token objects that then get merged together
    var useTokensCore = function (theme) {
        // get the base styles all merged together, these will only depend on internal tokens and theme
        return cache(function () { return immutable_merge_1.immutableMerge.apply(void 0, tokens.map(function (value) { return mapToTokens(value, theme, getComponentInfo); })); }, [theme]);
    };
    // attach a customize function to generate a new use
    useTokensCore.customize = function () {
        var newTokens = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            newTokens[_i] = arguments[_i];
        }
        var mergedTokens = __spreadArrays(tokens, newTokens);
        return buildUseTokens.apply(void 0, __spreadArrays([getComponentInfo], mergedTokens));
    };
    return useTokensCore;
}
exports.buildUseTokens = buildUseTokens;
//# sourceMappingURL=buildUseTokens.js.map