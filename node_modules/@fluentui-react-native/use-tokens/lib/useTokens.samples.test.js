var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { Text, View } from 'react-native';
import toJson from 'enzyme-to-json';
import * as React from 'react';
import { mount } from 'enzyme';
import { buildUseTokens } from './buildUseTokens';
import { mergeStyles } from '@fluentui-react-native/merge-props';
import { immutableMerge } from '@fluentui-react-native/immutable-merge';
/**
 * The default/base theme just contains base values
 */
var baseTheme = {
    globals: {
        backgroundColor: 'white',
        color: 'black',
        borderColor: 'blue',
        fontFamily: 'Arial',
        fontSize: 12,
    },
    components: {},
};
var current = { theme: baseTheme };
var useTheme = function () { return current.theme; };
var setActiveTheme = function (theme) {
    current.theme = (theme && immutableMerge(baseTheme, theme)) || baseTheme;
};
/**
 * this wrapper solves the (so-far) inexplicable type errors from the matchers in typescript
 */
function snapshotTestTree(tree) {
    expect(toJson(tree)).toMatchSnapshot();
}
/**
 * Helper function used to look up a component in the theme. Having this injected allows this module to not be dependent on the shape of
 * the theme used.
 */
var getComponentInfo = function (theme, name) { return theme.components[name]; };
describe('useTokens samples', function () {
    /**
     * Sample #1 - Themeable text element
     *
     * This adds some default opinions for how a text element should be styled but only allows for customization
     * via theming
     */
    var useTokensSample1 = buildUseTokens(getComponentInfo, 
    /** first the default values should come from the global theme section */
    function (t) { return ({
        color: t.globals.color,
        fontFamily: t.globals.fontFamily,
        fontSize: t.globals.fontSize,
    }); }, 
    /** next we should look for a component reference to overlay */
    'SampleText');
    var SampleText1 = function (props) {
        // standard props splitting
        var style = props.style, children = props.children, rest = __rest(props, ["style", "children"]);
        // typically this would start with a call to retrieve the theme from the context via whatever method is appropriate
        var theme = useTheme();
        // next the tokens are resolved from the theme, a cache specific to this theme is returned as well to allow for
        // style objects to not be rebuilt unnecessarily
        var _a = useTokensSample1(theme), tokens = _a[0], cache = _a[1];
        // build up the text style, or the full props as appropriate
        var styleFromTokens = cache(
        /**
         * first build the style object
         * - this executes once for every unique set of keys.
         * - The cache is already unique for this theme
         */
        function () { return (__assign({}, tokens)); }, 
        /**
         * now specify the keys
         * - because the only changing variable is the theme
         * - ...and all the style properties are either constant or come from the tokens
         * - ...no keys need to be specified
         * - this means that only one style object will be created per component + theme pair
         */
        []);
        // merge the props from the tokens with anything passed in via style. This is internally cached via object identity
        // so the merged style object won't change identity unless one of the two inputs changes identity.
        var mergedStyle = mergeStyles(styleFromTokens, style);
        // now just render the element, forwarding the props, setting the merged style, then passing the children as appropriate
        return (React.createElement(Text, __assign({}, rest, { style: mergedStyle }), children));
    };
    beforeEach(function () {
        setActiveTheme();
    });
    /** first render the component with no updates */
    it('Sample1Text rendering with no overrides', function () {
        var tree = mount(React.createElement(SampleText1, null, "Sample1a"));
        snapshotTestTree(tree);
    });
    /** now re-theme the component via the components in the theme */
    it('Sample1Text rendering with some custom settings in the theme', function () {
        setActiveTheme({
            components: {
                SampleText: {
                    color: 'pink',
                    fontSize: 24,
                },
            },
        });
        var tree = mount(React.createElement(SampleText1, null, "Sample1b"));
        snapshotTestTree(tree);
    });
    // the Sample2Text component is built the same way as sample1, just using the new hook that has been created
    var SampleText2 = function (props) {
        var color = props.color, style = props.style, children = props.children, rest = __rest(props, ["color", "style", "children"]);
        var theme = useTheme();
        // this starts the same as sample1, extract tokens from the theme and get a theme specific cache object
        var _a = useTokensSample1(theme), tokens = _a[0], cache = _a[1];
        // now when building up the style this time, the resulting style object is based upon both the theme and the passed
        // in value of colors. Because the theme is already part of the cache definition, only color needs to be a key
        var styleFromTokens = cache(
        /** build the style, only patch the color if it has a value, otherwise the theme value would get stomped if color was undefined */
        function () { return (__assign(__assign({}, tokens), (color && { color: color }))); }, 
        /** use color as an additional key for the style */
        [color]);
        // now just render, this time merging styles inline to make it a bit shorter
        return (React.createElement(Text, __assign({}, rest, { style: mergeStyles(styleFromTokens, style) }), children));
    };
    /** rendering the Sample2 component with the base theme */
    it('Sample2Text rendering with defaults and a color override', function () {
        var tree = mount(React.createElement(View, null,
            React.createElement(SampleText2, null, "Sample2 with defaults"),
            React.createElement(SampleText2, { color: "green" }, "Sample2 with color override via prop")));
        snapshotTestTree(tree);
    });
    /** now re-theme the component via the components in the theme */
    it('Sample2Text rendering with some custom settings in the theme', function () {
        setActiveTheme({
            components: {
                SampleText: {
                    fontSize: 18,
                    fontFamily: 'Helvetica',
                },
            },
        });
        var tree = mount(React.createElement(View, null,
            React.createElement(SampleText2, null, "Sample2 with theme overrides set"),
            React.createElement(SampleText2, { color: "purple" }, "Sample2 with theme and color prop override")));
        snapshotTestTree(tree);
    });
});
//# sourceMappingURL=useTokens.samples.test.js.map