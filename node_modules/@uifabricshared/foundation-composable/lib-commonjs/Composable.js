"use strict";
/* eslint-disable */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Composable_slots_1 = require("./Composable.slots");
var slots_1 = require("./slots");
var foundation_settings_1 = require("@uifabricshared/foundation-settings");
function atomicRender(Slots, _renderData) {
    var children = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        children[_i - 2] = arguments[_i];
    }
    return slots_1.renderSlot.apply(void 0, __spreadArrays([Slots.root, undefined], children));
}
exports.atomicRender = atomicRender;
function atomicUsePrepareProps(props, useStyling) {
    var slotProps = foundation_settings_1.mergeSettings(useStyling(props), { root: props });
    return { slotProps: slotProps };
}
exports.atomicUsePrepareProps = atomicUsePrepareProps;
/**
 * Ensure the composable is set up correctly, fill in missing functions and turn slots into
 * object format rather than the shorthand format.
 *
 * @param options - partial options definition to turn into full options
 */
function _validateOptions(options) {
    var numSlots = (options.slots && Object.getOwnPropertyNames(options.slots).length) || 0;
    if (!numSlots) {
        throw 'A composable component must have at least one slot specified';
    }
    else if (numSlots > 1) {
        if (!options.render) {
            throw 'A composable component with multiple slots cannot use the default render implementation';
        }
    }
    // ensure slots are in slot with filter format
    for (var key in options.slots) {
        var slot = options.slots[key];
        if (slot && (typeof slot !== 'object' || !slot.slotType)) {
            options.slots[key] = { slotType: slot };
        }
    }
    if (!options.useStyling) {
        options.useStyling = function () {
            return {};
        };
    }
    // use atomic handlers for usePrepareProps / render if necessary
    options.render = options.render || atomicRender;
    options.usePrepareProps = options.usePrepareProps || atomicUsePrepareProps;
    // return options as the full type rather than a partial
    return options;
}
/**
 * Create a component that can be composed into other objects to remove extra levels from the tree
 *
 * @param options - composable options which define the behavior of the component
 */
function composable(definition) {
    // ensure we are correctly configured
    var options = _validateOptions(definition);
    // create the actual implementation
    var render = function (userProps) {
        // split out children, they will be excluded from the prop preparation phase
        var _a = userProps, children = _a.children, props = __rest(_a, ["children"]);
        // prepare the props, all the way down the tree, also build the slots
        var _b = Composable_slots_1.useCompoundPrepare(props, options), renderData = _b.renderData, Slots = _b.Slots;
        // now do the render, adding the children back in
        return options.render(Slots, renderData, children);
    };
    render.displayName = options.displayName;
    render.__composable = options;
    return render;
}
exports.composable = composable;
/**
 * Helper to create a composable implementation of a simple atomic component
 *
 * @param target - slot type to create an atomic component from
 * @param usePrepareProps - prop processing implementation.
 * @param filter - optional filter.  If set it allows stripping properties before they are passed to target
 */
function atomic(target, usePrepareProps, filter) {
    return composable({
        usePrepareProps: usePrepareProps,
        slots: { root: { slotType: target, filter: filter } },
        render: atomicRender,
    });
}
exports.atomic = atomic;
//# sourceMappingURL=Composable.js.map