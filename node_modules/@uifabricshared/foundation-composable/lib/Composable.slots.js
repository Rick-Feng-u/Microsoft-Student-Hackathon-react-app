/* eslint-disable */
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import * as React from 'react';
import { mergeSettings } from '@uifabricshared/foundation-settings';
import { mergeProps } from '@fluentui-react-native/merge-props';
function _mergeAndFilterProps(propsBase, propsExtra, filter) {
    // do a basic merge, not mutating if nothing changed
    var props = mergeProps(propsBase, propsExtra);
    if (filter && props) {
        var removeMask_1 = {};
        Object.getOwnPropertyNames(props).forEach(function (key) {
            if (!filter(key)) {
                removeMask_1[key] = undefined;
            }
        });
        props = mergeProps(props, removeMask_1);
    }
    return props;
}
/**
 * Helper function to add the _canCompose settings to a given render function
 * @param fn - function to decorate with _canCompose
 */
function _createSlotRenderFunction(fn) {
    fn._canCompose = true;
    return fn;
}
function createSlotRenderInfo(composable, slotInfo) {
    var renderInfo = { composable: composable, slotInfo: slotInfo };
    var slots = composable && composable.slots;
    if (slots) {
        var Slots_1 = (renderInfo.Slots = {});
        var childInfo_1 = (renderInfo.childInfo = {});
        Object.getOwnPropertyNames(slots).forEach(function (slot) {
            var _a = slots[slot], slotType = _a.slotType, filter = _a.filter;
            var composable = (typeof slotType !== 'string' && slotType.__composable) ||
                undefined;
            var childRenderInfo = (childInfo_1[slot] = createSlotRenderInfo(composable, slots[slot]));
            if (composable) {
                // create the actual closure for rendering handing it a reference to the render info
                Slots_1[slot] = _createSlotRenderFunction(function (extraProps) {
                    var children = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        children[_i - 1] = arguments[_i];
                    }
                    var renderData = childRenderInfo.renderData, Slots = childRenderInfo.Slots;
                    if (filter || extraProps) {
                        var toMerge = { root: _mergeAndFilterProps(renderData.slotProps.root, extraProps, filter) };
                        renderData.slotProps = mergeSettings(renderData.slotProps, toMerge);
                    }
                    return composable.render.apply(composable, __spreadArrays([Slots, renderData], children));
                });
            }
            else {
                // non-composable components should just render directly
                Slots_1[slot] = _createSlotRenderFunction(function (extraProps) {
                    var children = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        children[_i - 1] = arguments[_i];
                    }
                    var props = _mergeAndFilterProps(childRenderInfo.renderData.slotProps.root, extraProps, filter);
                    return React.createElement.apply(React, __spreadArrays([slotType, props], children));
                });
            }
        });
    }
    return renderInfo;
}
function useUpdateRenderData(props, info) {
    // update the render data for this level of the hierarchy
    if (info.composable) {
        var _a = info.composable, usePrepareProps = _a.usePrepareProps, useStyling = _a.useStyling;
        info.renderData = usePrepareProps(props, useStyling) || {};
    }
    else {
        info.renderData = { slotProps: { root: props } };
    }
    // now traverse to children if needed
    var childInfo = info.childInfo;
    if (childInfo) {
        var slotProps_1 = info.renderData.slotProps || {};
        Object.getOwnPropertyNames(childInfo).forEach(function (child) {
            useUpdateRenderData(slotProps_1[child], childInfo[child]);
        });
    }
    // return the updated renderData and cached Slots
    return { renderData: info.renderData, Slots: info.Slots };
}
/**
 * Driver function for the prop preparation phase of rendering a composable control
 *
 * @param props - user props send to prepare props
 * @param composable - composable for this component
 */
export function useCompoundPrepare(props, composable) {
    // create the slot render info (which may be a tree) and store it into state once.  Note that this will also create any
    // needed closures for the slots to ensure they don't get recreated over the lifetime of the component
    var renderInfo = React.useMemo(function () { return createSlotRenderInfo(composable); }, []);
    // process the props of the tree using the created/retrieved renderInfo
    return useUpdateRenderData(props, renderInfo);
}
//# sourceMappingURL=Composable.slots.js.map