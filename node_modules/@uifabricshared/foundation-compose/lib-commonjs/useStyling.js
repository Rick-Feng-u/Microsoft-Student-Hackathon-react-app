"use strict";
/* eslint-disable */
Object.defineProperty(exports, "__esModule", { value: true });
var themed_settings_1 = require("@uifabricshared/themed-settings");
var theming_ramp_1 = require("@uifabricshared/theming-ramp");
var foundation_tokens_1 = require("@uifabricshared/foundation-tokens");
var theme_types_1 = require("@fluentui-react-native/theme-types");
var default_theme_1 = require("@fluentui-react-native/default-theme");
var memo_cache_1 = require("@fluentui-react-native/memo-cache");
/* tslint:disable-next-line no-any */
function getOptionsFromObj(obj) {
    var objType = obj && typeof obj;
    return ((objType === 'object' || objType === 'function') && obj.__composable) || undefined;
}
exports.getOptionsFromObj = getOptionsFromObj;
function _getSettingsFromTheme(theme, name) {
    return theming_ramp_1.getSettings(theme, name);
}
function _getHasToken(slots) {
    var slotTokens = {};
    Object.keys(slots).forEach(function (slotName) {
        var slot = slots[slotName];
        var slotType = (typeof slot !== 'object' ? slot : slot.slotType);
        var options = getOptionsFromObj(slotType);
        slotTokens[slotName] = (options && options.resolvedTokens && options.resolvedTokens.tokenKeys) || undefined;
    });
    return function (target, key) {
        return slotTokens[target] && slotTokens[target].hasOwnProperty(key);
    };
}
function useStylingCore(props, options, instanceMemoCache, lookupOverride) {
    // get the theme value from the context (or the default theme if it is not set)
    var theme = theme_types_1.useTheme() || default_theme_1.defaultFluentTheme;
    // resolve the array of settings for these options
    lookupOverride = lookupOverride || props;
    var _a = themed_settings_1.getThemedSettings(options.settings, theme, instanceMemoCache, lookupOverride, _getSettingsFromTheme), settings = _a.settings, getMemoValue = _a.getMemoValue;
    // finish by processing the tokens and turning IComponentSettings into ISlotProps (this removes things like _overrides)
    return theming_ramp_1.returnAsSlotProps(foundation_tokens_1.processTokens(props, theme, settings, options.resolvedTokens, getMemoValue));
}
/**
 * return a useStyling implementation, in the form of IUseComposeStyling, based on the passed in styleSettings.  The
 * styleSettings will be captured in the created closure and will be set up to enable the appropriate levels of caching.
 *
 * @param options - style settings to configure this function.  Note that this should be scoped to a single component.
 * @param name - optional base name to use as a cache key
 */
function initializeStyling(options) {
    // process the tokens and get them ready to render
    var styles = options.styles, slots = options.slots;
    options.resolvedTokens = foundation_tokens_1.buildComponentTokens(styles, _getHasToken(slots));
    // memo cache root for this component, keyed on options
    var getMemoValue = memo_cache_1.getMemoCache(options);
    // create a useStyling implementation for this component type (per type, not per instance)
    return function (props, lookupOverride) {
        return useStylingCore(props, options, getMemoValue, lookupOverride);
    };
}
exports.initializeStyling = initializeStyling;
//# sourceMappingURL=useStyling.js.map