export interface ISlotProps<TProps extends object = object> {
    root: TProps;
}
export declare type IWithTokens<T, TTokens extends object> = T & {
    tokens?: TTokens;
};
export declare type IPartialSlotProps<TSlotProps extends ISlotProps> = {
    [K in keyof TSlotProps]+?: Partial<TSlotProps[K]>;
};
export declare type IComponentSettings<TSlotProps extends ISlotProps = ISlotProps> = IPartialSlotProps<TSlotProps> & {
    _precedence?: string[];
    _overrides?: IComponentSettingsCollection<IWithTokens<IComponentSettings<TSlotProps>, object>>;
};
export declare type IComponentSettingsCollection<TSettings extends IWithTokens<IComponentSettings, object> = IWithTokens<IComponentSettings, object>> = {
    [key: string]: TSettings;
};
/**
 * overrides are looked up using an object where override names are evaluated against the object.  If the values are truthy
 * the override will be applied.
 */
export interface IOverrideMask {
    [key: string]: any;
}
/**
 * alternatively look them up with a passed in function
 */
export declare type IOverrideFunction = (name: string) => boolean;
/**
 * Lookup overrides by function or by mask
 */
export declare type IOverrideLookup = IOverrideFunction | IOverrideMask;
//# sourceMappingURL=Settings.types.d.ts.map