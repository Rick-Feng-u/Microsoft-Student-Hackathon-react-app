/* eslint-disable */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import { immutableMergeCore } from '@fluentui-react-native/immutable-merge';
import { mergeProps } from '@fluentui-react-native/merge-props';
/**
 * an individual settings block is a set of slotProps, with an additional collection of tokens.
 */
var _mergeSettingsOptions = {
    // tokens should be merged but not recurse
    tokens: 0,
    // all other objects should be treated as props
    object: mergeProps,
    // overrides have a collection of objects which each are treated as settings
    get _overrides() {
        return { object: this };
    },
};
/**
 * A collection of settings simply applies settings down one level
 */
var _mergeCollectionOptions = {
    object: _mergeSettingsOptions,
};
/**
 * Merge settings together.  This routine should work for IComponentSettings types or ISlotProps
 * @param settings - settings to merge together
 */
export function mergeSettings() {
    var settings = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        settings[_i] = arguments[_i];
    }
    return immutableMergeCore.apply(void 0, __spreadArrays([_mergeSettingsOptions], settings));
}
/**
 * Merge collections of settings together.  This can handle theme resolution or merging sets of overrides
 * @param collections - the settings collections to merge
 */
export function mergeSettingsCollection() {
    var collections = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        collections[_i] = arguments[_i];
    }
    return immutableMergeCore.apply(void 0, __spreadArrays([_mergeCollectionOptions], collections));
}
export function getActiveOverrides(target, lookup) {
    var hasOverride = typeof lookup === 'function' ? lookup : function (o) { return lookup[o]; };
    return (target && target._precedence && target._precedence.filter(function (o) { return hasOverride(o); })) || [];
}
/**
 * Apply overrides to `target`, producing a new settings object if any need to be applied.
 *
 * `overrideLookup` is an object where keys will be looked up in the order specified by the precedence array.
 * The values inside this structure can be any type but will cause the override to apply if they are truthy
 */
export function resolveSettingsOverrides(target, overrideLookup) {
    var result = target;
    var _overrides = target._overrides, _precedence = target._precedence;
    if (overrideLookup && _overrides && _precedence) {
        var overrides = getActiveOverrides(target, overrideLookup);
        for (var _i = 0, overrides_1 = overrides; _i < overrides_1.length; _i++) {
            var override = overrides_1[_i];
            result = mergeSettings(result, result._overrides[override]);
        }
    }
    return result;
}
/**
 * Turn a settings object into a slot props object.
 * @param target - settings block to strip the settings specific information from
 */
export function slotPropsFromSettings(target) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    var _overrides = target._overrides, _precedence = target._precedence, slotProps = __rest(target, ["_overrides", "_precedence"]);
    return slotProps;
}
//# sourceMappingURL=Settings.js.map