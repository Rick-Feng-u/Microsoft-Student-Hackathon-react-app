"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var merge_props_1 = require("@fluentui-react-native/merge-props");
/**
 * Helper to make it easy to create a style factory function.  Function statics are super convenient
 * but kind of annoying to set up
 *
 * @param fn - function to decorate with keys
 * @param keys - keys to append as a static to the function
 */
function styleFunction(fn, keys) {
    fn._keys = keys;
    return fn;
}
exports.styleFunction = styleFunction;
function _copyToken(props, key, target, targetObj) {
    if (props[key] !== undefined) {
        targetObj[target || key] = props[key];
    }
}
function _lookupOrCopyToken(props, theme, entry, style) {
    var key = entry.source, lookup = entry.lookup;
    if (props[key] !== undefined) {
        var lookupResult = lookup && lookup(theme);
        var val = props[key];
        if (typeof val === 'string' && lookupResult && lookupResult[val] !== undefined) {
            val = lookupResult[val];
        }
        style[entry.target || key] = val;
    }
}
function _processSlotEntries(props, theme, mapping) {
    var slotProps = {};
    if (mapping.toStyle.length > 0) {
        var slotStyle = {};
        for (var _i = 0, _a = mapping.toStyle; _i < _a.length; _i++) {
            var entry = _a[_i];
            _lookupOrCopyToken(props, theme, entry, slotStyle);
        }
        if (Object.keys(slotStyle).length > 0) {
            slotProps.style = slotStyle;
        }
    }
    for (var _b = 0, _c = mapping.toTokens; _b < _c.length; _b++) {
        var entry = _c[_b];
        _copyToken(props, entry.source, entry.target, slotProps);
    }
    return slotProps;
}
function _processStyleFunctions(functions, tokenProps, theme) {
    if (functions && functions.length > 0) {
        return merge_props_1.mergeProps.apply(void 0, functions.map(function (fn) { return fn(tokenProps, theme); }));
    }
    return undefined;
}
/**
 * This is the worker function that does the work of either retrieving a cached props/style from the cache
 * or building up the new props/style set
 */
function _getCachedPropsForSlot(props, tokenProps, theme, slotName, getMemoValue, keys, mappings, finalizer) {
    // get the cache key for this entry
    var tokens = tokenProps.tokens, tokenKeys = tokenProps.tokenKeys, deltas = tokenProps.deltas;
    return getMemoValue(function () {
        var newProps = merge_props_1.mergeProps(props, slotName === 'root' ? tokenKeys : undefined, _processSlotEntries(tokens, theme, mappings), _processStyleFunctions(mappings.functions, tokens, theme));
        if (finalizer) {
            newProps = finalizer(newProps, slotName);
        }
        return newProps;
    }, __spreadArrays([slotName], keys.map(function (val) { return (deltas[val] !== undefined ? deltas[val] : ''); })))[0];
}
/**
 * This function runs at component definition time (once for every component type) and
 * processes the styleFactories on each of the slots and builds up handler functions that
 * obtain or build the cached props.
 *
 * @param factories - collection of slot style factories
 * @param hasToken - a function that returns whether or not a slot supports a given token
 */
function buildComponentTokens(factories, hasToken) {
    var tokenKeys = {};
    var handlers = {};
    // iterate through each factory and generate a handler for it.  Note that even if no styleFactories
    // are provided within it will still generate the handler to do style caching and finalization
    Object.getOwnPropertyNames(factories).forEach(function (slot) {
        var factoriesBase = factories[slot];
        var mappings = { toStyle: [], toTokens: [], functions: [] };
        var toStyle = mappings.toStyle, toTokens = mappings.toTokens, functions = mappings.functions;
        var slotKeys = {};
        // if there are style factories provided split them into ones that target tokens and ones that target styles
        if (factoriesBase) {
            var factorySet = Array.isArray(factoriesBase) ? factoriesBase : [factoriesBase];
            for (var _i = 0, factorySet_1 = factorySet; _i < factorySet_1.length; _i++) {
                var set = factorySet_1[_i];
                if (typeof set === 'function') {
                    functions.push(set);
                    set._keys.forEach(function (key) {
                        slotKeys[key] = undefined;
                    });
                }
                else {
                    var setArray = Array.isArray(set) ? set : [set];
                    for (var _a = 0, setArray_1 = setArray; _a < setArray_1.length; _a++) {
                        var operation = setArray_1[_a];
                        slotKeys[operation.source] = undefined;
                        var target = operation.target || operation.source;
                        if (hasToken && hasToken(slot, target)) {
                            toTokens.push(operation);
                        }
                        else {
                            toStyle.push(operation);
                        }
                    }
                }
            }
        }
        // add the collected keys to the root token keys
        Object.assign(tokenKeys, slotKeys);
        // create the closure for the handler and return that in the object
        handlers[slot] = function (props, tokenProps, theme, slotName, getValue) {
            var keys = Object.getOwnPropertyNames(slotKeys);
            return _getCachedPropsForSlot(props, tokenProps, theme, slotName, getValue, keys, mappings);
        };
    });
    return { tokenKeys: tokenKeys, handlers: handlers };
}
exports.buildComponentTokens = buildComponentTokens;
//# sourceMappingURL=Token.function.js.map