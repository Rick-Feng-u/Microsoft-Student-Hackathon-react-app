import { MockButton } from './MockButton';
import { theme } from './MockTheme';
import { getMemoCache } from '@fluentui-react-native/memo-cache';
var b1 = {
    tokens: {
        fontSize: 'large',
        fontWeight: 900,
        color: 'buttonText',
        backgroundColor: 'buttonBackground',
        borderWidth: 1,
        borderRadius: 2,
        borderColor: '#c1c1c1',
        captionColor: 'blue',
    },
};
var b1resolved = {
    root: {
        style: {
            borderColor: '#c1c1c1',
            borderWidth: 1,
            borderRadius: 2,
            backgroundColor: 'blue',
        },
    },
    content: {
        fontSize: 'large',
        fontWeight: 900,
        color: 'buttonText',
    },
    subContent: {
        style: {
            fontSize: 14,
            fontWeight: 900,
            color: 'blue',
        },
    },
    icon: {
        style: {
            color: 'yellow',
        },
    },
};
var b1resolvedRecurse = {
    root: {
        style: {
            borderColor: '#c1c1c1',
            borderWidth: 1,
            borderRadius: 2,
            backgroundColor: 'blue',
        },
    },
    content: {
        // note that these three values will get cleared by the content element, but remerged by the base class, this
        // is an issue with the test component implementation, not of the framework
        fontSize: 'large',
        fontWeight: 900,
        color: 'buttonText',
        style: {
            fontSize: 14,
            fontWeight: 900,
            color: 'yellow',
        },
    },
    subContent: {
        style: {
            fontSize: 14,
            fontWeight: 900,
            color: 'blue',
        },
    },
    icon: {
        style: {
            color: 'yellow',
        },
    },
};
describe('Token settings unit tests', function () {
    test('resolve base settings', function () {
        var cache = getMemoCache();
        var resolved = MockButton({}, b1, theme, cache, false);
        expect(resolved).toEqual(b1resolved);
    });
    test('resolve base with recursion', function () {
        var cache = getMemoCache();
        var resolved = MockButton({}, b1, theme, cache, true);
        expect(resolved).toEqual(b1resolvedRecurse);
    });
    test('two default buttons return same object', function () {
        var cache = getMemoCache();
        var resolved1 = MockButton({ content: 'button1' }, b1, theme, cache, false);
        var resolved2 = MockButton({ content: 'button2' }, b1, theme, cache, false);
        expect(resolved1).toEqual(resolved2);
        Object.getOwnPropertyNames(resolved1).forEach(function (key) {
            expect(resolved1[key]).toBe(resolved2[key]);
        });
    });
    test('setting props that match defaults keep same object', function () {
        var cache = getMemoCache();
        var resolved1 = MockButton({ content: 'button1' }, b1, theme, cache, false);
        var resolved2 = MockButton({ content: 'button2', color: 'buttonText' }, b1, theme, cache, false);
        expect(resolved1).toEqual(resolved2);
        Object.getOwnPropertyNames(resolved1).forEach(function (key) {
            expect(resolved1[key]).toBe(resolved2[key]);
        });
    });
    test('prop token overrides produce partial new object', function () {
        var cache = getMemoCache();
        var resolved1 = MockButton({ content: 'button1' }, b1, theme, cache, false);
        var resolved2 = MockButton({ content: 'button2', color: 'purple' }, b1, theme, cache, false);
        expect(resolved1).not.toBe(resolved2);
        expect(resolved1['root']).toBe(resolved2['root']);
        expect(resolved1.content).not.toBe(resolved2.content);
    });
    test('prop token overrides, multiple values are memoized', function () {
        var cache = getMemoCache();
        var resolved1 = MockButton({ content: 'button1', borderRadius: 3, color: 'purple' }, b1, theme, cache, false);
        var resolved2 = MockButton({ content: 'button2', color: 'purple', borderRadius: 3 }, b1, theme, cache, false);
        expect(resolved1).toEqual(resolved2);
        Object.getOwnPropertyNames(resolved1).forEach(function (key) {
            expect(resolved1[key]).toBe(resolved2[key]);
        });
    });
    test('prop token overrides, different keys same value produce different objects', function () {
        var cache = getMemoCache();
        var resolved1 = MockButton({ content: 'button1', backgroundColor: 'purple' }, b1, theme, cache, false);
        var resolved2 = MockButton({ content: 'button2', color: 'purple' }, b1, theme, cache, false);
        expect(resolved1).not.toBe(resolved2);
        expect(resolved1['root']).not.toBe(resolved2['root']);
        expect(resolved1.content).not.toBe(resolved2.content);
    });
});
//# sourceMappingURL=Token.test.js.map